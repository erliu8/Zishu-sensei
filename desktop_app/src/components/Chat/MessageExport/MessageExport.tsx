/**
 * Ê∂àÊÅØÂØºÂá∫ÁªÑ‰ª∂
 * 
 * ÂäüËÉΩÔºö
 * - ÂØºÂá∫‰∏∫ Markdown
 * - ÂØºÂá∫‰∏∫ HTML
 * - ÂØºÂá∫‰∏∫ PDF
 * - ÂØºÂá∫‰∏∫Á∫ØÊñáÊú¨
 * - Ëá™ÂÆö‰πâÂØºÂá∫ËåÉÂõ¥ÔºàÂÖ®ÈÉ®/ÈÄâ‰∏≠/Êó•ÊúüËåÉÂõ¥Ôºâ
 * - ÂØºÂá∫ËÆæÁΩÆÔºàÂåÖÂê´Êó∂Èó¥Êà≥„ÄÅÁî®Êà∑ÂêçÁ≠âÔºâ
 */

import React, { useState, useCallback } from 'react'
import { 
  Download, 
  FileText, 
  FileCode, 
  File,
  Calendar,
  Settings,
  X,
  Check
} from 'lucide-react'
import clsx from 'clsx'
import styles from './MessageExport.module.css'

// ==================== Á±ªÂûãÂÆö‰πâ ====================

export interface Message {
  id: string
  content: string
  sender: string
  timestamp: number
  [key: string]: any
}

export interface ExportOptions {
  /** ÂØºÂá∫Ê†ºÂºè */
  format: 'markdown' | 'html' | 'pdf' | 'text'
  /** ÂØºÂá∫ËåÉÂõ¥ */
  range: 'all' | 'selected' | 'dateRange'
  /** ÂºÄÂßãÊó•ÊúüÔºàËåÉÂõ¥ÂØºÂá∫Êó∂Ôºâ */
  startDate?: Date
  /** ÁªìÊùüÊó•ÊúüÔºàËåÉÂõ¥ÂØºÂá∫Êó∂Ôºâ */
  endDate?: Date
  /** ÈÄâ‰∏≠ÁöÑÊ∂àÊÅØ IDÔºàÈÄâ‰∏≠ÂØºÂá∫Êó∂Ôºâ */
  selectedIds?: string[]
  /** ÊòØÂê¶ÂåÖÂê´Êó∂Èó¥Êà≥ */
  includeTimestamp: boolean
  /** ÊòØÂê¶ÂåÖÂê´ÂèëÈÄÅËÄÖ */
  includeSender: boolean
  /** ÊòØÂê¶ÂåÖÂê´ÂÖÉÊï∞ÊçÆ */
  includeMetadata: boolean
  /** Êñá‰ª∂Âêç */
  filename?: string
}

export interface MessageExportProps {
  /** ÊâÄÊúâÊ∂àÊÅØ */
  messages: Message[]
  /** ÈÄâ‰∏≠ÁöÑÊ∂àÊÅØ ID */
  selectedMessageIds?: string[]
  /** ÂØºÂá∫ÂÆåÊàêÂõûË∞É */
  onExportComplete?: (success: boolean, error?: Error) => void
  /** Ëá™ÂÆö‰πâÁ±ªÂêç */
  className?: string
  /** ÊòØÂê¶ÊòæÁ§∫ */
  visible?: boolean
  /** ÂÖ≥Èó≠ÂõûË∞É */
  onClose?: () => void
}

// ==================== Â∑•ÂÖ∑ÂáΩÊï∞ ====================

/**
 * Ê†ºÂºèÂåñÊó•ÊúüÊó∂Èó¥
 */
const formatDateTime = (timestamp: number): string => {
  const date = new Date(timestamp)
  return date.toLocaleString('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  })
}

/**
 * ÂØºÂá∫‰∏∫ Markdown
 */
const exportToMarkdown = (messages: Message[], options: ExportOptions): string => {
  let markdown = '# ËÅäÂ§©ËÆ∞ÂΩï\n\n'
  
  if (options.includeMetadata) {
    markdown += `> ÂØºÂá∫Êó∂Èó¥: ${formatDateTime(Date.now())}\n`
    markdown += `> Ê∂àÊÅØÊï∞Èáè: ${messages.length}\n\n`
  }

  markdown += '---\n\n'

  messages.forEach((message, index) => {
    if (options.includeSender) {
      markdown += `## ${message.sender}\n\n`
    }

    if (options.includeTimestamp) {
      markdown += `*${formatDateTime(message.timestamp)}*\n\n`
    }

    markdown += `${message.content}\n\n`

    if (index < messages.length - 1) {
      markdown += '---\n\n'
    }
  })

  return markdown
}

/**
 * ÂØºÂá∫‰∏∫ HTML
 */
const exportToHTML = (messages: Message[], options: ExportOptions): string => {
  let html = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ËÅäÂ§©ËÆ∞ÂΩï</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 20px;
      line-height: 1.6;
      color: #333;
      background: #f9fafb;
    }
    h1 {
      color: #111827;
      border-bottom: 3px solid #3b82f6;
      padding-bottom: 10px;
    }
    .metadata {
      background: #eff6ff;
      padding: 15px;
      border-radius: 8px;
      margin: 20px 0;
      color: #1e40af;
      font-size: 14px;
    }
    .message {
      background: #fff;
      padding: 20px;
      margin: 20px 0;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .message-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #e5e7eb;
    }
    .sender {
      font-weight: 600;
      color: #111827;
      font-size: 16px;
    }
    .timestamp {
      color: #6b7280;
      font-size: 13px;
    }
    .content {
      color: #374151;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    code {
      background: #f3f4f6;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }
    pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
    }
    pre code {
      background: transparent;
      padding: 0;
      color: inherit;
    }
  </style>
</head>
<body>
  <h1>üí¨ ËÅäÂ§©ËÆ∞ÂΩï</h1>
`

  if (options.includeMetadata) {
    html += `
  <div class="metadata">
    <div><strong>ÂØºÂá∫Êó∂Èó¥:</strong> ${formatDateTime(Date.now())}</div>
    <div><strong>Ê∂àÊÅØÊï∞Èáè:</strong> ${messages.length}</div>
  </div>
`
  }

  messages.forEach(message => {
    html += `
  <div class="message">
`
    if (options.includeSender || options.includeTimestamp) {
      html += `    <div class="message-header">\n`
      
      if (options.includeSender) {
        html += `      <div class="sender">${escapeHtml(message.sender)}</div>\n`
      }
      
      if (options.includeTimestamp) {
        html += `      <div class="timestamp">${formatDateTime(message.timestamp)}</div>\n`
      }
      
      html += `    </div>\n`
    }

    html += `    <div class="content">${escapeHtml(message.content)}</div>
  </div>
`
  })

  html += `
</body>
</html>`

  return html
}

/**
 * ÂØºÂá∫‰∏∫Á∫ØÊñáÊú¨
 */
const exportToText = (messages: Message[], options: ExportOptions): string => {
  let text = '========================================\n'
  text += '           ËÅäÂ§©ËÆ∞ÂΩï\n'
  text += '========================================\n\n'

  if (options.includeMetadata) {
    text += `ÂØºÂá∫Êó∂Èó¥: ${formatDateTime(Date.now())}\n`
    text += `Ê∂àÊÅØÊï∞Èáè: ${messages.length}\n\n`
  }

  text += '========================================\n\n'

  messages.forEach((message, index) => {
    if (options.includeSender) {
      text += `[${message.sender}]\n`
    }

    if (options.includeTimestamp) {
      text += `Êó∂Èó¥: ${formatDateTime(message.timestamp)}\n`
    }

    text += `\n${message.content}\n\n`

    if (index < messages.length - 1) {
      text += '----------------------------------------\n\n'
    }
  })

  return text
}

/**
 * ËΩ¨‰πâ HTML
 */
const escapeHtml = (text: string): string => {
  const div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}

/**
 * ‰∏ãËΩΩÊñá‰ª∂
 */
const downloadFile = (content: string, filename: string, mimeType: string) => {
  const blob = new Blob([content], { type: mimeType })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/**
 * ÁîüÊàê PDFÔºà‰ΩøÁî®ÊµèËßàÂô®ÊâìÂç∞ÂäüËÉΩÔºâ
 */
const exportToPDF = async (messages: Message[], options: ExportOptions) => {
  // ÁîüÊàê HTML ÂÜÖÂÆπ
  const htmlContent = exportToHTML(messages, options)
  
  // ÂàõÂª∫Êñ∞Á™óÂè£
  const printWindow = window.open('', '_blank')
  if (!printWindow) {
    throw new Error('Êó†Ê≥ïÊâìÂºÄÊâìÂç∞Á™óÂè£ÔºåËØ∑Ê£ÄÊü•ÊµèËßàÂô®ÂºπÁ™óËÆæÁΩÆ')
  }

  // ÂÜôÂÖ• HTML
  printWindow.document.write(htmlContent)
  printWindow.document.close()

  // Á≠âÂæÖÂä†ËΩΩÂÆåÊàêÂêéÊâìÂç∞
  printWindow.onload = () => {
    printWindow.focus()
    printWindow.print()
  }
}

// ==================== ‰∏ªÁªÑ‰ª∂ ====================

export const MessageExport: React.FC<MessageExportProps> = ({
  messages,
  selectedMessageIds = [],
  onExportComplete,
  className,
  visible = true,
  onClose,
}) => {
  // ==================== Áä∂ÊÄÅ ====================

  const [options, setOptions] = useState<ExportOptions>({
    format: 'markdown',
    range: 'all',
    includeTimestamp: true,
    includeSender: true,
    includeMetadata: true,
  })

  const [isExporting, setIsExporting] = useState(false)
  const [exportSuccess, setExportSuccess] = useState(false)

  // ==================== ÂØºÂá∫ÈÄªËæë ====================

  /**
   * Á≠õÈÄâË¶ÅÂØºÂá∫ÁöÑÊ∂àÊÅØ
   */
  const getMessagesToExport = useCallback((): Message[] => {
    let filtered = messages

    // ÊåâËåÉÂõ¥Á≠õÈÄâ
    if (options.range === 'selected' && options.selectedIds) {
      filtered = messages.filter(m => options.selectedIds!.includes(m.id))
    } else if (options.range === 'dateRange') {
      filtered = messages.filter(m => {
        if (options.startDate && m.timestamp < options.startDate.getTime()) return false
        if (options.endDate && m.timestamp > options.endDate.getTime()) return false
        return true
      })
    }

    return filtered
  }, [messages, options])

  /**
   * ÊâßË°åÂØºÂá∫
   */
  const handleExport = useCallback(async () => {
    setIsExporting(true)
    setExportSuccess(false)

    try {
      const messagesToExport = getMessagesToExport()

      if (messagesToExport.length === 0) {
        throw new Error('Ê≤°ÊúâÂèØÂØºÂá∫ÁöÑÊ∂àÊÅØ')
      }

      const timestamp = new Date().toISOString().split('T')[0]
      const defaultFilename = `chat_export_${timestamp}`

      switch (options.format) {
        case 'markdown':
          const markdown = exportToMarkdown(messagesToExport, options)
          downloadFile(
            markdown,
            options.filename || `${defaultFilename}.md`,
            'text/markdown'
          )
          break

        case 'html':
          const html = exportToHTML(messagesToExport, options)
          downloadFile(
            html,
            options.filename || `${defaultFilename}.html`,
            'text/html'
          )
          break

        case 'text':
          const text = exportToText(messagesToExport, options)
          downloadFile(
            text,
            options.filename || `${defaultFilename}.txt`,
            'text/plain'
          )
          break

        case 'pdf':
          await exportToPDF(messagesToExport, options)
          break
      }

      setExportSuccess(true)
      onExportComplete?.(true)

      // 2ÁßíÂêéÂÖ≥Èó≠
      setTimeout(() => {
        onClose?.()
      }, 2000)
    } catch (error) {
      console.error('ÂØºÂá∫Â§±Ë¥•:', error)
      onExportComplete?.(false, error as Error)
    } finally {
      setIsExporting(false)
    }
  }, [options, getMessagesToExport, onExportComplete, onClose])

  // ==================== Ê∏≤Êüì ====================

  if (!visible) return null

  const messagesToExport = getMessagesToExport()
  const canExport = messagesToExport.length > 0

  return (
    <div className={clsx(styles.container, className)}>
      <div className={styles.header}>
        <h2 className={styles.title}>
          <Download size={20} />
          ÂØºÂá∫ËÅäÂ§©ËÆ∞ÂΩï
        </h2>
        {onClose && (
          <button onClick={onClose} className={styles.closeButton}>
            <X size={20} />
          </button>
        )}
      </div>

      <div className={styles.content}>
        {/* ÂØºÂá∫Ê†ºÂºè */}
        <div className={styles.section}>
          <label className={styles.label}>ÂØºÂá∫Ê†ºÂºè</label>
          <div className={styles.formatGrid}>
            <button
              onClick={() => setOptions(prev => ({ ...prev, format: 'markdown' }))}
              className={clsx(
                styles.formatButton,
                options.format === 'markdown' && styles.formatButtonActive
              )}
            >
              <FileCode size={24} />
              <span>Markdown</span>
              <span className={styles.formatDesc}>ÈÄÇÂêàÊäÄÊúØÊñáÊ°£</span>
            </button>

            <button
              onClick={() => setOptions(prev => ({ ...prev, format: 'html' }))}
              className={clsx(
                styles.formatButton,
                options.format === 'html' && styles.formatButtonActive
              )}
            >
              <FileText size={24} />
              <span>HTML</span>
              <span className={styles.formatDesc}>ÈÄÇÂêàÁΩëÈ°µÊü•Áúã</span>
            </button>

            <button
              onClick={() => setOptions(prev => ({ ...prev, format: 'text' }))}
              className={clsx(
                styles.formatButton,
                options.format === 'text' && styles.formatButtonActive
              )}
            >
              <File size={24} />
              <span>Á∫ØÊñáÊú¨</span>
              <span className={styles.formatDesc}>ÁÆÄÂçïÊòìËØª</span>
            </button>

            <button
              onClick={() => setOptions(prev => ({ ...prev, format: 'pdf' }))}
              className={clsx(
                styles.formatButton,
                options.format === 'pdf' && styles.formatButtonActive
              )}
            >
              <FileText size={24} />
              <span>PDF</span>
              <span className={styles.formatDesc}>ÈÄÇÂêàÊâìÂç∞</span>
            </button>
          </div>
        </div>

        {/* ÂØºÂá∫ËåÉÂõ¥ */}
        <div className={styles.section}>
          <label className={styles.label}>ÂØºÂá∫ËåÉÂõ¥</label>
          <div className={styles.rangeOptions}>
            <label className={styles.radioOption}>
              <input
                type="radio"
                checked={options.range === 'all'}
                onChange={() => setOptions(prev => ({ ...prev, range: 'all' }))}
              />
              <span>ÂÖ®ÈÉ®Ê∂àÊÅØ ({messages.length})</span>
            </label>

            {selectedMessageIds.length > 0 && (
              <label className={styles.radioOption}>
                <input
                  type="radio"
                  checked={options.range === 'selected'}
                  onChange={() => setOptions(prev => ({
                    ...prev,
                    range: 'selected',
                    selectedIds: selectedMessageIds
                  }))}
                />
                <span>ÈÄâ‰∏≠ÁöÑÊ∂àÊÅØ ({selectedMessageIds.length})</span>
              </label>
            )}

            <label className={styles.radioOption}>
              <input
                type="radio"
                checked={options.range === 'dateRange'}
                onChange={() => setOptions(prev => ({ ...prev, range: 'dateRange' }))}
              />
              <span>Êó•ÊúüËåÉÂõ¥</span>
            </label>
          </div>

          {/* Êó•ÊúüËåÉÂõ¥ÈÄâÊã© */}
          {options.range === 'dateRange' && (
            <div className={styles.dateRange}>
              <div className={styles.dateField}>
                <Calendar size={16} />
                <input
                  type="date"
                  value={options.startDate ? options.startDate.toISOString().split('T')[0] : ''}
                  onChange={(e) => setOptions(prev => ({
                    ...prev,
                    startDate: e.target.value ? new Date(e.target.value) : undefined
                  }))}
                  className={styles.dateInput}
                  placeholder="ÂºÄÂßãÊó•Êúü"
                />
              </div>
              <span>Ëá≥</span>
              <div className={styles.dateField}>
                <Calendar size={16} />
                <input
                  type="date"
                  value={options.endDate ? options.endDate.toISOString().split('T')[0] : ''}
                  onChange={(e) => setOptions(prev => ({
                    ...prev,
                    endDate: e.target.value ? new Date(e.target.value) : undefined
                  }))}
                  className={styles.dateInput}
                  placeholder="ÁªìÊùüÊó•Êúü"
                />
              </div>
            </div>
          )}
        </div>

        {/* ÂØºÂá∫ËÆæÁΩÆ */}
        <div className={styles.section}>
          <label className={styles.label}>
            <Settings size={16} />
            ÂØºÂá∫ËÆæÁΩÆ
          </label>
          <div className={styles.checkboxGroup}>
            <label className={styles.checkbox}>
              <input
                type="checkbox"
                checked={options.includeTimestamp}
                onChange={(e) => setOptions(prev => ({
                  ...prev,
                  includeTimestamp: e.target.checked
                }))}
              />
              <span>ÂåÖÂê´Êó∂Èó¥Êà≥</span>
            </label>

            <label className={styles.checkbox}>
              <input
                type="checkbox"
                checked={options.includeSender}
                onChange={(e) => setOptions(prev => ({
                  ...prev,
                  includeSender: e.target.checked
                }))}
              />
              <span>ÂåÖÂê´ÂèëÈÄÅËÄÖ</span>
            </label>

            <label className={styles.checkbox}>
              <input
                type="checkbox"
                checked={options.includeMetadata}
                onChange={(e) => setOptions(prev => ({
                  ...prev,
                  includeMetadata: e.target.checked
                }))}
              />
              <span>ÂåÖÂê´ÂÖÉÊï∞ÊçÆ</span>
            </label>
          </div>
        </div>

        {/* È¢ÑËßà‰ø°ÊÅØ */}
        <div className={styles.preview}>
          <div className={styles.previewItem}>
            <span>Â∞ÜÂØºÂá∫Ê∂àÊÅØ:</span>
            <strong>{messagesToExport.length} Êù°</strong>
          </div>
          <div className={styles.previewItem}>
            <span>ÂØºÂá∫Ê†ºÂºè:</span>
            <strong>{options.format.toUpperCase()}</strong>
          </div>
        </div>
      </div>

      <div className={styles.footer}>
        {exportSuccess && (
          <div className={styles.successMessage}>
            <Check size={16} />
            <span>ÂØºÂá∫ÊàêÂäü!</span>
          </div>
        )}
        
        <button
          onClick={handleExport}
          disabled={!canExport || isExporting}
          className={clsx(styles.exportButton, exportSuccess && styles.exportButtonSuccess)}
        >
          {isExporting ? (
            <>
              <span className={styles.spinner} />
              <span>ÂØºÂá∫‰∏≠...</span>
            </>
          ) : exportSuccess ? (
            <>
              <Check size={18} />
              <span>ÂØºÂá∫ÊàêÂäü</span>
            </>
          ) : (
            <>
              <Download size={18} />
              <span>ÂºÄÂßãÂØºÂá∫</span>
            </>
          )}
        </button>
      </div>
    </div>
  )
}

export default MessageExport

