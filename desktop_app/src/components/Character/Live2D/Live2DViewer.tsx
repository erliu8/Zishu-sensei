/**
 * Live2DÊü•ÁúãÂô®ReactÁªÑ‰ª∂
 * 
 * Êèê‰æõÂÆåÊï¥ÁöÑLive2DÊ®°ÂûãÊü•ÁúãÂíå‰∫§‰∫íÂäüËÉΩ
 * ÊîØÊåÅÊ®°ÂûãÂä†ËΩΩ„ÄÅÂä®ÁîªÊí≠Êîæ„ÄÅÁî®Êà∑‰∫§‰∫íÁ≠â
 */

import React, { 
  useRef, 
  useEffect, 
  useState, 
  useCallback, 
  useMemo,
  forwardRef,
  useImperativeHandle 
} from 'react'
import {
  Live2DViewerProps,
  Live2DViewerConfig,
  Live2DLoadState,
  Live2DViewerEvent,
  Live2DAnimationConfig,
  Live2DRenderConfig,
  Live2DViewerControls,
  LIVE2D_DEFAULTS,
  UseLive2DViewerReturn
} from '@/types/live2d'
import type { Live2DService } from '@/services/live2d'
import { Live2DControlPanel } from './Live2DControlPanel'
import { Live2DLoadingIndicator } from './Live2DLoadingIndicator'
import { useLive2DViewer } from '@/hooks/useLive2DViewer'
import { printWebGLDiagnostics, checkTauriWebGLIssues } from '@/utils/webgl-diagnostics'
import './Live2DViewer.css'

/**
 * Live2DÊü•ÁúãÂô®ÁªÑ‰ª∂ÂºïÁî®Êé•Âè£
 */
export interface Live2DViewerRef extends UseLive2DViewerReturn {
  /** Ëé∑ÂèñÁîªÂ∏ÉÂÖÉÁ¥† */
  getCanvas: () => HTMLCanvasElement | null
  /** Ëé∑ÂèñLive2DÊúçÂä°ÂÆû‰æã */
  getService: () => Live2DService | null
  /** Êà™ÂõæÂäüËÉΩ */
  takeScreenshot: (format?: 'png' | 'jpeg', quality?: number) => string | null
  /** ËøõÂÖ•/ÈÄÄÂá∫ÂÖ®Â±è */
  toggleFullscreen: () => void
}

/**
 * Live2DÊü•ÁúãÂô®‰∏ªÁªÑ‰ª∂
 */
export const Live2DViewer = forwardRef<Live2DViewerRef, Live2DViewerProps>(({ 
  config,
  modelConfig,
  renderConfig,
  onEvent: emitEvent,
  onModelLoad: _onModelLoad,
  onAnimationPlay,
  onInteraction: _onInteraction,
  onError,
  children,
  className = '',
  style = {}
}, ref) => {
  // ==================== Refs ====================
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const initialModelLoadedRef = useRef(false)

  // ==================== State ====================
  const [isFullscreen, setIsFullscreen] = useState(false)
  const [showControls, setShowControls] = useState(true)
  const [controlsAutoHideTimer, setControlsAutoHideTimer] = useState<NodeJS.Timeout | null>(null)
  
  // ÊãñÂä®Áä∂ÊÄÅ
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 })
  const [dragInitialPosition, setDragInitialPosition] = useState({ x: 0, y: 0 }) // ÊãñÊãΩÂºÄÂßãÊó∂ÁöÑÊ®°Âûã‰ΩçÁΩÆ
  const [modelPosition, setModelPosition] = useState({ x: 0, y: 0 })

  // ==================== ÂêàÂπ∂ÈÖçÁΩÆ ====================
  const finalConfig = useMemo((): Live2DViewerConfig => ({
    canvasSize: config?.canvasSize ?? LIVE2D_DEFAULTS.CANVAS_SIZE,
    renderConfig: { ...LIVE2D_DEFAULTS.RENDER_CONFIG, ...(config?.renderConfig ?? {}) },
    controls: { ...LIVE2D_DEFAULTS.CONTROLS, ...(config?.controls ?? {}) },
    performance: { ...LIVE2D_DEFAULTS.PERFORMANCE, ...(config?.performance ?? {}) },
    enableInteraction: config?.enableInteraction ?? true,
    enableAutoIdleAnimation: config?.enableAutoIdleAnimation ?? true,
    idleAnimationInterval: config?.idleAnimationInterval ?? 10000,
    debugMode: config?.debugMode ?? false,
    responsive: config?.responsive ?? true,
  }), [config])

  const finalRenderConfig = useMemo((): Partial<Live2DRenderConfig> => ({
    ...finalConfig.renderConfig,
    ...renderConfig
  }), [finalConfig.renderConfig, renderConfig])

  // ==================== ‰ΩøÁî®Ëá™ÂÆö‰πâHook ====================
  const viewerApi = useLive2DViewer(canvasRef, finalConfig)

  const {
    isReady,
    loadState,
    modelState,
    animationInfo,
    error,
    loadModel,
    stopAnimation,
    setExpression,
    resetTransform,
    destroy
  } = viewerApi

  // ==================== ‰∫ã‰ª∂Â§ÑÁêÜÂô® ====================
  
  // ‰∫§‰∫í‰∫ã‰ª∂Áî± ControlPanel ÁöÑÈº†Ê†áÁßªÂä®Ëß¶ÂèëÂ±ïÁ§∫ÊéßÂà∂Âå∫

  /**
   * Â§ÑÁêÜÂä®ÁîªÊí≠Êîæ
   */
  const handleAnimationPlay = useCallback((config: Live2DAnimationConfig) => {
    onAnimationPlay?.(config)
    ;(emitEvent as any)?.(Live2DViewerEvent.ANIMATION_START, { animationConfig: config })
  }, [onAnimationPlay, emitEvent])

  /**
   * Â§ÑÁêÜÈîôËØØ
   */
  const handleError = useCallback((error: Error) => {
    console.error('Live2D Viewer Error:', error)
    onError?.(error)
    ;(emitEvent as any)?.(Live2DViewerEvent.MODEL_LOAD_ERROR, { error })
  }, [onError, emitEvent])

  // ==================== ÊéßÂà∂Èù¢ÊùøËá™Âä®ÈöêËóè ====================

  /**
   * ÈáçÁΩÆÊéßÂà∂Èù¢ÊùøËá™Âä®ÈöêËóèËÆ°Êó∂Âô®
   */
  const resetControlsAutoHide = useCallback(() => {
    if (controlsAutoHideTimer) {
      clearTimeout(controlsAutoHideTimer)
    }

    if (finalConfig.controls?.autoHide) {
      const timer = setTimeout(() => {
        setShowControls(false)
      }, finalConfig.controls.autoHideDelay || 3000)
      
      setControlsAutoHideTimer(timer)
    }
  }, [controlsAutoHideTimer, finalConfig.controls])

  /**
   * Â§ÑÁêÜÈº†Ê†áÁßªÂä® - ÊòæÁ§∫ÊéßÂà∂Èù¢Êùø
   */
  const handleMouseMove = useCallback(() => {
    if (finalConfig.controls?.autoHide && !showControls) {
      setShowControls(true)
    }
    resetControlsAutoHide()
  }, [finalConfig.controls?.autoHide, showControls, resetControlsAutoHide])

  // ==================== ÂÖ®Â±èÂäüËÉΩ ====================

  /**
   * ÂàáÊç¢ÂÖ®Â±èÊ®°Âºè
   */
  const toggleFullscreen = useCallback(async () => {
    if (!containerRef.current) return

    try {
      if (!isFullscreen) {
        // ËøõÂÖ•ÂÖ®Â±è
        if (containerRef.current.requestFullscreen) {
          await containerRef.current.requestFullscreen()
        } else if ((containerRef.current as any).webkitRequestFullscreen) {
          await (containerRef.current as any).webkitRequestFullscreen()
        } else if ((containerRef.current as any).msRequestFullscreen) {
          await (containerRef.current as any).msRequestFullscreen()
        }
      } else {
        // ÈÄÄÂá∫ÂÖ®Â±è
        if (document.exitFullscreen) {
          await document.exitFullscreen()
        } else if ((document as any).webkitExitFullscreen) {
          await (document as any).webkitExitFullscreen()
        } else if ((document as any).msExitFullscreen) {
          await (document as any).msExitFullscreen()
        }
      }
    } catch (error) {
      console.error('Failed to toggle fullscreen:', error)
    }
  }, [isFullscreen])

  /**
   * ÁõëÂê¨ÂÖ®Â±èÁä∂ÊÄÅÂèòÂåñ
   */
  const handleFullscreenChange = useCallback(() => {
    const isCurrentlyFullscreen = !!(
      document.fullscreenElement ||
      (document as any).webkitFullscreenElement ||
      (document as any).msFullscreenElement
    )
    setIsFullscreen(isCurrentlyFullscreen)
  }, [])

  // ==================== Êà™ÂõæÂäüËÉΩ ====================

  /**
   * Êà™ÂèñÁîªÂ∏ÉÂÜÖÂÆπ
   */
  const takeScreenshot = useCallback((format: 'png' | 'jpeg' = 'png', quality: number = 1.0): string | null => {
    if (!canvasRef.current) return null

    try {
      const mimeType = format === 'png' ? 'image/png' : 'image/jpeg'
      return canvasRef.current.toDataURL(mimeType, quality)
    } catch (error) {
      console.error('Failed to take screenshot:', error)
      return null
    }
  }, [])

  // ==================== ÁîüÂëΩÂë®Êúü ====================

  // ÂèñÊ∂àÊ†áÂøó
  const cancelledRef = useRef(false)

  /**
   * ÁªÑ‰ª∂ÂàùÂßãÂåñ
   */
  useEffect(() => {
    // ÈáçÁΩÆÂèñÊ∂àÊ†áÂøó
    cancelledRef.current = false
    if (!canvasRef.current) return

    // ÊâßË°åWebGLËØäÊñ≠
    printWebGLDiagnostics()
    
    const tauriIssues = checkTauriWebGLIssues()
    if (tauriIssues.length > 0) {
      console.warn('‚ö†Ô∏è Tauri WebGLÈóÆÈ¢ò:', tauriIssues)
    }

    const maybeLoadInitialModel = async () => {
      try {
        if (cancelledRef.current) return
        if (isReady && modelConfig && !initialModelLoadedRef.current) {
          await loadModel(modelConfig, finalRenderConfig)
          if (cancelledRef.current) return
          initialModelLoadedRef.current = true
          
          // üîß [FIX] Ê®°ÂûãÂä†ËΩΩÂÆåÊàêÂêéÔºåÂêåÊ≠•Ê®°Âûã‰ΩçÁΩÆÂà∞ÁªÑ‰ª∂Áä∂ÊÄÅ
          const transform = viewerApi.service?.getModelTransform?.(modelConfig.id)
          if (transform) {
            setModelPosition({ x: transform.x, y: transform.y })
          }
          
          ;(emitEvent as any)?.(Live2DViewerEvent.VIEWER_READY, { viewerId: 'live2d-viewer' })
        }
      } catch (error) {
        if (cancelledRef.current) return
        console.error('Failed to initialize Live2D viewer:', error)
        handleError(error as Error)
      }
    }

    maybeLoadInitialModel()

    return () => {
      // ËøôÈáåÂè™ÂÅöÊú¨Ê¨° effect ÁöÑÂèñÊ∂àÔºå‰∏çÈîÄÊØÅÊúçÂä°ÔºàÈÅøÂÖç‰æùËµñÂèòÊõ¥Êó∂Á†¥ÂùèÂàùÂßãÂåñÊó∂Â∫èÔºâ
      cancelledRef.current = true
    }
  }, [isReady, modelConfig, finalRenderConfig, destroy, handleError, emitEvent, viewerApi.service])

  // ==================== CanvasÁä∂ÊÄÅÁõëÊéßÂíåÊÅ¢Â§ç ====================
  useEffect(() => {
    if (!canvasRef.current) return

    const checkAndRecoverCanvasState = () => {
      const canvas = canvasRef.current
      if (!canvas) return

      const computedStyle = window.getComputedStyle(canvas)
      const rect = canvas.getBoundingClientRect()
      
      const canvasState = {
        timestamp: new Date().toISOString(),
        canvasExists: !!canvas,
        display: computedStyle.display,
        visibility: computedStyle.visibility,
        opacity: computedStyle.opacity,
        dimensions: {
          clientWidth: canvas.clientWidth,
          clientHeight: canvas.clientHeight,
          offsetWidth: canvas.offsetWidth,
          offsetHeight: canvas.offsetHeight
        },
        boundingRect: {
          width: rect.width,
          height: rect.height,
          top: rect.top,
          left: rect.left,
          visible: rect.width > 0 && rect.height > 0
        },
        webglContext: !!(canvas.getContext('webgl') || canvas.getContext('webgl2')),
        parentElement: canvas.parentElement?.tagName,
        hasParent: !!canvas.parentElement
      }
      
      // üîß [CRITICAL] Ê£ÄÊü•Âπ∂‰øÆÂ§çCanvasÈóÆÈ¢ò
      let needsRecovery = false
      
      // Ê£ÄÊü•1: CanvasÊ≤°ÊúâÁà∂ÂÖÉÁ¥†ÔºàÁÉ≠ÈáçËΩΩÈóÆÈ¢òÔºâ
      if (!canvasState.hasParent) {
        console.error('‚ùå [CRITICAL] CanvasÂ§±ÂéªÁà∂ÂÖÉÁ¥†ÔºÅËøôÈÄöÂ∏∏ÊòØÁÉ≠ÈáçËΩΩÂØºËá¥ÁöÑ')
        needsRecovery = true
      }
      
      // Ê£ÄÊü•2: CanvasÂ∞∫ÂØ∏‰∏∫0
      if (canvasState.dimensions.clientWidth === 0 || canvasState.dimensions.clientHeight === 0) {
        console.error('‚ùå [CRITICAL] CanvasÂ∞∫ÂØ∏‰∏∫0ÔºÅ')
        needsRecovery = true
      }
      
      // Ê£ÄÊü•3: CanvasÊ†∑Âºè‰∏¢Â§±
      if (!canvasState.display || canvasState.display === '') {
        console.error('‚ùå [CRITICAL] CanvasÊ†∑Âºè‰∏¢Â§±ÔºÅ')
        needsRecovery = true
      }
      
      // ÊâßË°åÊÅ¢Â§çÊìç‰Ωú
      if (needsRecovery) {
        // üîß [CRITICAL FIX] Âº∫Âà∂Ê∏ÖÁêÜÊóßÁöÑCanvasÁä∂ÊÄÅ
        try {
          // Ê∏ÖÁêÜÂèØËÉΩÂ≠òÂú®ÁöÑWebGL‰∏ä‰∏ãÊñá
          const gl = canvas.getContext('webgl2') || canvas.getContext('webgl')
          if (gl) {
            const loseContext = gl.getExtension('WEBGL_lose_context')
            if (loseContext) {
              loseContext.loseContext()
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [RECOVERY] Ê∏ÖÁêÜWebGL‰∏ä‰∏ãÊñáÊó∂Âá∫Áé∞Ë≠¶Âëä:', error)
        }
        
        // üîß [CRITICAL FIX] ÂàõÂª∫ÂÖ®Êñ∞ÁöÑCanvasÂÖÉÁ¥†
        const newCanvas = document.createElement('canvas')
        
        // ËÆæÁΩÆCanvasÂ±ûÊÄß
        newCanvas.width = finalConfig.canvasSize.width
        newCanvas.height = finalConfig.canvasSize.height
        newCanvas.style.display = 'block'
        newCanvas.style.width = '100%'
        newCanvas.style.height = '100%'
        newCanvas.style.cursor = finalConfig.enableInteraction ? 'pointer' : 'default'
        newCanvas.style.position = 'relative'
        
        // üîß [CRITICAL FIX] Âº∫Âà∂ËÆæÁΩÆCanvasÁöÑÂÜÖÈÉ®Â±ûÊÄß
        Object.defineProperty(newCanvas, 'clientWidth', {
          get: () => finalConfig.canvasSize.width,
          configurable: true
        })
        Object.defineProperty(newCanvas, 'clientHeight', {
          get: () => finalConfig.canvasSize.height,
          configurable: true
        })
        
        // ÊõøÊç¢CanvasÂÖÉÁ¥†
        if (containerRef.current) {
          try {
            // ÁßªÈô§ÊóßCanvas
            if (canvas.parentNode) {
              canvas.parentNode.removeChild(canvas)
            }

            // Ê∑ªÂä†Êñ∞Canvas
            containerRef.current.appendChild(newCanvas)

            // ÂêåÊ≠• React ref ÊåáÂêëÁöÑÊñ∞ canvas
            ;(canvasRef as any).current = newCanvas

            // Êõ¥Êñ∞ÊúçÂä°‰∏≠ÁöÑCanvasÂºïÁî®ÔºàÂ∞ΩÈáèÂ∞ëÂÅöÔºåÊúçÂä°‰ºöÂú®ÂÖ®Â±Ä‰∫ã‰ª∂‰∏≠Ëá™ÊàëÈáçÂª∫Ôºâ
            const serviceRef = (viewerApi as any).serviceRef
            if (serviceRef?.current) {
              try { (serviceRef.current as any).canvas = newCanvas } catch {}
              if ((serviceRef.current as any).loader) {
                try { (serviceRef.current as any).loader.canvas = newCanvas } catch {}
              }
            }

            // ÂêëÂÖ®Â±ÄÊ¥æÂèë Canvas ÊÅ¢Â§ç‰∫ã‰ª∂Ôºå‰∫§Áî± Hook Áªü‰∏ÄÂ§ÑÁêÜÈáçÂª∫
            window.dispatchEvent(new Event('live2d-canvas-recovered'))
          } catch (error) {
            console.error('‚ùå CanvasÂÖÉÁ¥†ÊõøÊç¢Â§±Ë¥•:', error)
          }
        }
        
        // üîß [CRITICAL] ÈáçÁΩÆÊ®°ÂûãÂä†ËΩΩÁä∂ÊÄÅÔºåÁ°Æ‰øùÁÉ≠ÈáçËΩΩÂêéËÉΩÈáçÊñ∞Âä†ËΩΩÊ®°Âûã
        initialModelLoadedRef.current = false
        
        // ÈáçÊñ∞Ê£ÄÊü•Áä∂ÊÄÅÂπ∂Ëß¶ÂèëÊúçÂä°ÈáçÊñ∞ÂàùÂßãÂåñ
        setTimeout(() => {
          // üîß [CRITICAL] Ëß¶ÂèëÊúçÂä°ÈáçÊñ∞Ê£ÄÊü•ÂíåÂàùÂßãÂåñ
          if (canvasRef.current) {
            // ÂÖºÂÆπÊóßÁöÑÁªÑ‰ª∂ÂÜÖ‰∫ã‰ª∂Ôºà‰øùÁïôÔºâ
            const event = new CustomEvent('canvas-recovered')
            canvasRef.current.dispatchEvent(event)
          }
        }, 100)
      }
    }

    // Á´ãÂç≥Ê£ÄÊü•‰∏ÄÊ¨°
    checkAndRecoverCanvasState()
    
    // ËÆæÁΩÆÂÆöÊúüÊ£ÄÊü• - ÂáèÂ∞ëÈ¢ëÁéáÈÅøÂÖçÊéßÂà∂Âè∞Âô™Èü≥
    const interval = setInterval(checkAndRecoverCanvasState, 30000) // ÊØè30ÁßíÊ£ÄÊü•‰∏ÄÊ¨°
    
    return () => {
      clearInterval(interval)
    }
  }, [canvasRef.current, containerRef.current, finalConfig.canvasSize, finalConfig.enableInteraction])

  // Áã¨Á´ãÁöÑÂç∏ËΩΩÊ∏ÖÁêÜÔºö‰ªÖÂú®ÁªÑ‰ª∂ÁúüÊ≠£Âç∏ËΩΩÊó∂ÈîÄÊØÅÊúçÂä°
  useEffect(() => {
    return () => {
      cancelledRef.current = true
      initialModelLoadedRef.current = false
      destroy()
    }
  }, [destroy])

  /**
   * ËÆæÁΩÆÂÖ®Â±è‰∫ã‰ª∂ÁõëÂê¨
   */
  useEffect(() => {
    document.addEventListener('fullscreenchange', handleFullscreenChange)
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange)
    document.addEventListener('msfullscreenchange', handleFullscreenChange)

    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange)
      document.removeEventListener('webkitfullscreenchange', handleFullscreenChange)
      document.removeEventListener('msfullscreenchange', handleFullscreenChange)
    }
  }, [handleFullscreenChange])

  /**
   * Ê∏ÖÁêÜËá™Âä®ÈöêËóèËÆ°Êó∂Âô®
   */
  useEffect(() => {
    return () => {
      if (controlsAutoHideTimer) {
        clearTimeout(controlsAutoHideTimer)
      }
    }
  }, [controlsAutoHideTimer])

  /**
   * ÂàùÂßãÂåñÊ®°Âûã‰ΩçÁΩÆ - ÂΩìÊ®°ÂûãÂä†ËΩΩÂÆåÊàêÊó∂
   */
  useEffect(() => {
    if (modelState.loaded && viewerApi.isReady && viewerApi.getCurrentModel && viewerApi.service) {
      const currentModel = viewerApi.getCurrentModel()
      if (currentModel && currentModel.config?.id) {
        const transform = viewerApi.service.getModelTransform(currentModel.config.id)
        if (transform) {
          setModelPosition({ x: transform.x, y: transform.y })
        }
      }
    }
  }, [modelState.loaded, viewerApi.isReady])

  // ==================== ÊãñÂä®ÂíåÁº©Êîæ‰∫ã‰ª∂Â§ÑÁêÜ ====================
  
  /**
   * Èº†Ê†áÊåâ‰∏ã - ÂºÄÂßãÊãñÂä®
   */
  const handleMouseDown = useCallback((event: React.MouseEvent) => {
    console.log('üñ±Ô∏è [DRAG] Èº†Ê†áÊåâ‰∏ã:', { button: event.button, clientX: event.clientX, clientY: event.clientY })
    
    // üîß [FIX] Âè™Â§ÑÁêÜÂ∑¶ÈîÆÔºåÂè≥ÈîÆÂíå‰∏≠ÈîÆÁõ¥Êé•ÂøΩÁï•Ôºà‰∏çÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫ÔºåËÆ©Âè≥ÈîÆËèúÂçïÊ≠£Â∏∏ÊòæÁ§∫Ôºâ
    if (event.button !== 0) {
      console.log('üñ±Ô∏è [DRAG] ÂøΩÁï•ÈùûÂ∑¶ÈîÆ‰∫ã‰ª∂Ôºåbutton =', event.button)
      return
    }
    
    console.log('üñ±Ô∏è [DRAG] ÂºÄÂßãÊãñÊãΩÔºåÂΩìÂâçÊ®°Âûã‰ΩçÁΩÆ:', modelPosition)
    setIsDragging(true)
    setDragStart({ x: event.clientX, y: event.clientY })
    setDragInitialPosition({ x: modelPosition.x, y: modelPosition.y }) // ‰øùÂ≠òÂºÄÂßãÊãñÊãΩÊó∂ÁöÑÊ®°Âûã‰ΩçÁΩÆ
    event.preventDefault()
    event.stopPropagation() // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°ÔºåÈÅøÂÖçËß¶ÂèëÁÇπÂáª
  }, [modelPosition])

  /**
   * Èº†Ê†áÁßªÂä® - ÊãñÂä®‰∏≠
   */
  const handleMouseMoveForDrag = useCallback((event: React.MouseEvent) => {
    if (!isDragging) {
      return
    }
    
    if (!viewerApi.isReady) return

    // üîß [FIX] ‰ΩøÁî®ÊãñÊãΩÂºÄÂßãÊó∂ÁöÑÂàùÂßã‰ΩçÁΩÆ + Á¥ØÁßØÂÅèÁßªÈáèÔºåËÄå‰∏çÊòØÊØèÊ¨°Âü∫‰∫éÂΩìÂâç‰ΩçÁΩÆÁ¥ØÂä†
    const dx = event.clientX - dragStart.x
    const dy = event.clientY - dragStart.y

    // Ëé∑ÂèñÂΩìÂâçÊ®°Âûã
    const currentModel = viewerApi.getCurrentModel?.()
    if (!currentModel) return

    const service = (viewerApi as any).service
    if (!service) return

    // Ëé∑ÂèñÊ®°ÂûãID
    const modelId = currentModel.config?.id
    if (!modelId) return

    // üîß [FIX] Âü∫‰∫éÊãñÊãΩÂºÄÂßãÊó∂ÁöÑÂàùÂßã‰ΩçÁΩÆËÆ°ÁÆóÊñ∞‰ΩçÁΩÆ
    const newX = dragInitialPosition.x + dx
    const newY = dragInitialPosition.y + dy
    
    service.updateModelPosition(modelId, newX, newY)
    setModelPosition({ x: newX, y: newY })
  }, [isDragging, dragStart, dragInitialPosition, viewerApi])

  /**
   * Èº†Ê†áÊùæÂºÄ - ÁªìÊùüÊãñÂä®
   */
  const handleMouseUp = useCallback(() => {
    setIsDragging(false)
  }, [isDragging])

  /**
   * Èº†Ê†áÊªöËΩÆ - Áº©Êîæ
   * Ê≥®ÊÑèÔºö‰ΩøÁî® useEffect Ê∑ªÂä†ÂéüÁîüÁõëÂê¨Âô®ÔºåÂõ†‰∏∫ React ÁöÑ onWheel ÊòØ passive ÁöÑ
   */
  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const handleWheel = (event: WheelEvent) => {
      // ÂÖàÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫
      event.preventDefault()
      event.stopPropagation()
      
      if (!viewerApi.isReady) return
      
      const currentModel = viewerApi.getCurrentModel?.()
      if (!currentModel) return

      const service = (viewerApi as any).service
      if (!service) return

      // Ëé∑ÂèñÊ®°ÂûãID
      const modelId = currentModel.config?.id
      if (!modelId) return

      // Ëé∑ÂèñÂΩìÂâçÁº©Êîæ
      const transform = service.getModelTransform(modelId)
      if (!transform) return

      // ËÆ°ÁÆóÊñ∞ÁöÑÁº©ÊîæÂÄº
      const delta = event.deltaY > 0 ? -0.1 : 0.1
      const newScale = Math.max(0.1, Math.min(5.0, transform.scale + delta))
      
      service.updateModelScale(modelId, newScale)
    }

    // Ê∑ªÂä†Èùû passive ÁöÑÊªöËΩÆÁõëÂê¨Âô®Âà∞ canvas
    canvas.addEventListener('wheel', handleWheel, { passive: false })

    return () => {
      canvas.removeEventListener('wheel', handleWheel)
    }
  }, [viewerApi, canvasRef.current])

  // ==================== Êö¥Èú≤APIÁªôref ====================
  useImperativeHandle(ref, (): Live2DViewerRef => ({
    ...viewerApi,
    getCanvas: () => canvasRef.current,
    getService: () => null,
    takeScreenshot,
    toggleFullscreen
  }), [viewerApi, takeScreenshot, toggleFullscreen])

  // ==================== Ê∏≤ÊüìÊ†∑Âºè ====================
  const containerStyle: React.CSSProperties = {
    position: 'fixed',
    top: 0,
    left: 0,
    width: '100vw',
    height: '100vh',
    backgroundColor: finalConfig.theme?.backgroundColor || 'transparent',
    border: 'none',
    overflow: 'visible',
    pointerEvents: 'none', // ËÆ©ÂÆπÂô®‰∏çÈòªÊ≠¢Èº†Ê†á‰∫ã‰ª∂
    ...style
  }

  const canvasStyle: React.CSSProperties = {
    display: 'block',
    width: '100%',
    height: '100%',
    cursor: isDragging ? 'grabbing' : (finalConfig.enableInteraction ? 'grab' : 'default'),
    pointerEvents: 'auto' // Á°Æ‰øùcanvasÂèØ‰ª•Êé•Êî∂Èº†Ê†á‰∫ã‰ª∂
  }

  // ‰ΩøÁî®Á™óÂè£Â∞∫ÂØ∏ËÄå‰∏çÊòØÈÖçÁΩÆ‰∏≠ÁöÑÂõ∫ÂÆöÂ∞∫ÂØ∏
  const [canvasSize, setCanvasSize] = useState({
    width: typeof window !== 'undefined' ? window.innerWidth : finalConfig.canvasSize.width,
    height: typeof window !== 'undefined' ? window.innerHeight : finalConfig.canvasSize.height
  })

  // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñ
  useEffect(() => {
    const handleResize = () => {
      const newSize = {
        width: window.innerWidth,
        height: window.innerHeight
      }
      setCanvasSize(newSize)
      
      // ÈÄöÁü•ÊúçÂä°CanvasÂ∞∫ÂØ∏ÂèòÂåñ
      if (viewerApi.isReady && (viewerApi as any).service) {
        const service = (viewerApi as any).service
        if (service.app && service.app.renderer) {
          service.app.renderer.resize(newSize.width, newSize.height)
        }
      }
    }

    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [viewerApi])

  // ==================== ÁªÑ‰ª∂Ê∏≤Êüì ====================
  return (
    <div
      ref={containerRef}
      className={`live2d-viewer ${isFullscreen ? 'live2d-viewer--fullscreen' : ''} ${className}`}
      style={containerStyle}
      onMouseMove={(e) => {
        handleMouseMove()
        handleMouseMoveForDrag(e)
      }}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
      onMouseEnter={() => setShowControls(true)}
    >
      {/* ‰∏ªÁîªÂ∏É */}
      <canvas
        ref={canvasRef}
        className="live2d-viewer__canvas"
        style={canvasStyle}
        width={canvasSize.width}
        height={canvasSize.height}
        onClick={() => {
          // CanvasÁÇπÂáª‰∫ã‰ª∂ - Áî±Live2DÊúçÂä°Â§ÑÁêÜ
        }}
        onMouseDown={(event) => {
          handleMouseDown(event)
        }}
        onMouseUp={() => {
          // Èº†Ê†áÈáäÊîæ
        }}
        onContextMenu={() => {
          // ‰∏çÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°ÔºåËÆ©Âè≥ÈîÆ‰∫ã‰ª∂‰º†Êí≠Âà∞ PetWindowÔºå‰ªéËÄåËß¶ÂèëËá™ÂÆö‰πâËèúÂçï
          // Ê≥®ÊÑèÔºöÊàë‰ª¨‰∏çË∞ÉÁî® event.preventDefault() Êàñ event.stopPropagation()
          console.log('üñ±Ô∏è [CONTEXT MENU] Âè≥ÈîÆËèúÂçï‰∫ã‰ª∂Ëß¶ÂèëÔºå‰º†Êí≠Âà∞Áà∂ÁªÑ‰ª∂')
        }}
        onLoad={() => {
          // CanvasÂä†ËΩΩÂÆåÊàê
        }}
      />

      {/* Âä†ËΩΩÊåáÁ§∫Âô® */}
      {loadState !== Live2DLoadState.LOADED && loadState !== Live2DLoadState.IDLE && (
        <Live2DLoadingIndicator
          loadState={loadState}
          theme={finalConfig.theme}
          message={
            loadState === Live2DLoadState.LOADING ? 'Ê≠£Âú®Âä†ËΩΩLive2DÊ®°Âûã...' :
            loadState === Live2DLoadState.ERROR ? 'Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•' :
            loadState === Live2DLoadState.SWITCHING ? 'Ê≠£Âú®ÂàáÊç¢Ê®°Âûã...' : ''
          }
        />
      )}

      {/* ÊéßÂà∂Èù¢Êùø */}
      {finalConfig.controls && (showControls || !finalConfig.controls.autoHide) && isReady && (
        <Live2DControlPanel
          visible={showControls}
          controls={finalConfig.controls as Live2DViewerControls}
          modelState={modelState}
          animationInfo={animationInfo}
          availableAnimations={[]} // ËøôÈáåÈúÄË¶Å‰ªéÊúçÂä°‰∏≠Ëé∑Âèñ
          expressionCount={0} // ËøôÈáåÈúÄË¶Å‰ªéÊ®°Âûã‰∏≠Ëé∑Âèñ
          onPlayAnimation={handleAnimationPlay}
          onStopAnimation={stopAnimation}
          onSetExpression={setExpression}
          onResetTransform={resetTransform}
          onToggleFullscreen={toggleFullscreen}
          onUpdateSettings={(settings) => {
            // Êõ¥Êñ∞ÈÖçÁΩÆÁöÑÈÄªËæë
            ;(emitEvent as any)?.(Live2DViewerEvent.CONFIG_UPDATE, { config: settings })
          }}
        />
      )}

      {/* ÈîôËØØÊòæÁ§∫ */}
      {error && (
        <div className="live2d-viewer__error">
          <div className="live2d-viewer__error-content">
            <h3>Âä†ËΩΩÈîôËØØ</h3>
            <p>{error.message}</p>
            <button
              className="live2d-viewer__error-retry"
              onClick={() => {
                if (modelConfig) {
                  loadModel(modelConfig, finalRenderConfig)
                }
              }}
            >
              ÈáçËØï
            </button>
          </div>
        </div>
      )}

      {/* Ëá™ÂÆö‰πâÂÜÖÂÆπ */}
      {children}

      {/* Ë∞ÉËØï‰ø°ÊÅØ */}
      {finalConfig.debugMode && isReady && (
        <div className="live2d-viewer__debug">
          <div className="live2d-viewer__debug-info">
            <p>Load State: {loadState}</p>
            <p>Model: {modelState.loaded ? 'Â∑≤Âä†ËΩΩ' : 'Êú™Âä†ËΩΩ'}</p>
            <p>Animation: {animationInfo?.config.type || 'Êó†'}</p>
            <p>FPS: {finalConfig.performance?.targetFPS || 60}</p>
            <p>Interactive: {modelState.interactive ? 'ÊòØ' : 'Âê¶'}</p>
          </div>
        </div>
      )}
    </div>
  )
})

Live2DViewer.displayName = 'Live2DViewer'

export default Live2DViewer
