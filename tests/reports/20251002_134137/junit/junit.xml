<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="93" failures="190" skipped="16" tests="439" time="298.680" timestamp="2025-10-02T13:41:40.631521+08:00" hostname="autodl-container-ad7f4090ce-4bcd3160"><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_activate_character" time="0.816" /><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_character_template_loading" time="0.560" /><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_character_manager_initialization" time="0.315" /><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_character_memory_management" time="0.405" /><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_character_error_handling" time="0.372" /><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_character_validation" time="0.327" /><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_character_performance_metrics" time="0.400"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_character_performance_metrics&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_update_character" time="0.397"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_update_character&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_get_character" time="0.385"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_get_character&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_set_character_emotion" time="0.384"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_set_character_emotion&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_delete_character" time="0.698"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_delete_character&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_deactivate_character" time="0.384"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_deactivate_character&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_character_interaction" time="0.412"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_character_interaction&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_create_character" time="0.379"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_create_character&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_batch_character_operations" time="0.381"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_batch_character_operations&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_get_character_state" time="0.386"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_get_character_state&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_character_learning" time="0.376"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_character_learning&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_analyze_emotion" time="0.385"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_analyze_emotion&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_list_characters" time="0.404"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_list_characters&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.character.test_character_manager.TestCharacterManager" name="test_update_character_state" time="0.407"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_update_character_state&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.adapters.test_adapter_registry.TestRegistryFactoryFunctions" name="test_create_adapter_registry" time="0.583"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;test_adapter_registry.TestRegistryFactoryFunctions object at 0x7fa365c1f340&gt;

    def test_create_adapter_registry(self):
        """测试创建适配器注册中心"""
&gt;       registry = create_adapter_registry(
            enable_health_monitoring=True,
            enable_security=True,
            max_concurrent_operations=10
        )

tests/unit/adapters/test_adapter_registry.py:479: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:1361: in create_adapter_registry
    return AdapterRegistry(
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.adapters.test_adapter_registry.TestRegistryFactoryFunctions" name="test_default_registry_management" time="0.393"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;test_adapter_registry.TestRegistryFactoryFunctions object at 0x7fa365c185e0&gt;

    def test_default_registry_management(self):
        """测试默认注册中心管理"""
        # 创建新的注册中心
&gt;       registry = create_adapter_registry()

tests/unit/adapters/test_adapter_registry.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:1361: in create_adapter_registry
    return AdapterRegistry(
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.adapters.test_adapter_registry.TestRegistryFactoryFunctions" name="test_registry_configuration_options" time="0.384"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;test_adapter_registry.TestRegistryFactoryFunctions object at 0x7fa365c89760&gt;

    def test_registry_configuration_options(self):
        """测试注册中心配置选项"""
        # 开发环境配置
&gt;       dev_registry = create_adapter_registry(
            enable_health_monitoring=True,
            enable_security=False,
            enable_auto_recovery=False,
            max_concurrent_operations=3,
            health_check_interval=10
        )

tests/unit/adapters/test_adapter_registry.py:505: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:1361: in create_adapter_registry
    return AdapterRegistry(
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.adapters.test_adapter_registry.TestHealthMonitor" name="test_health_check_execution" time="0.392"><error message="failed on setup with &quot;TypeError: __init__() missing 1 required positional argument: 'registry'&quot;">self = &lt;test_adapter_registry.TestHealthMonitor object at 0x7fa365c1feb0&gt;

    @pytest.fixture
    def health_monitor(self):
        """创建健康监控器实例"""
&gt;       return HealthMonitor()
E       TypeError: __init__() missing 1 required positional argument: 'registry'

tests/unit/adapters/test_adapter_registry.py:419: TypeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestHealthMonitor" name="test_health_monitor_start_stop" time="0.381"><error message="failed on setup with &quot;TypeError: __init__() missing 1 required positional argument: 'registry'&quot;">self = &lt;test_adapter_registry.TestHealthMonitor object at 0x7fa365c1faf0&gt;

    @pytest.fixture
    def health_monitor(self):
        """创建健康监控器实例"""
&gt;       return HealthMonitor()
E       TypeError: __init__() missing 1 required positional argument: 'registry'

tests/unit/adapters/test_adapter_registry.py:419: TypeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestHealthMonitor" name="test_health_status_tracking" time="0.386"><error message="failed on setup with &quot;TypeError: __init__() missing 1 required positional argument: 'registry'&quot;">self = &lt;test_adapter_registry.TestHealthMonitor object at 0x7fa365c291f0&gt;

    @pytest.fixture
    def health_monitor(self):
        """创建健康监控器实例"""
&gt;       return HealthMonitor()
E       TypeError: __init__() missing 1 required positional argument: 'registry'

tests/unit/adapters/test_adapter_registry.py:419: TypeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestRegistryIntegration" name="test_full_adapter_lifecycle" time="0.384"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_full_adapter_lifecycle&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_has_adapter" time="0.388"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c181f0&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_unregister_adapter_success" time="0.386"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c89f70&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_dependency_cycle_detection" time="0.431"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c89940&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_registry_start_stop" time="0.395"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c89550&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_registry_statistics" time="0.381"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c187c0&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_unregister_nonexistent_adapter" time="0.385"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c0f2b0&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_list_adapters" time="0.383"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c0fc70&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_dependency_resolution" time="0.411"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c0f130&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_get_adapter_info" time="0.330"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c18490&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_registry_initialization" time="0.604"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c892b0&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_health_check_adapter" time="0.381"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c0f8e0&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_get_nonexistent_adapter" time="0.387"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c0f910&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_execute_adapter" time="0.602"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c0ffa0&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_get_adapter_success" time="0.539"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c0f610&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_register_adapter_success" time="0.723"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c89910&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestAdapterRegistry" name="test_register_adapter_duplicate" time="0.781"><error message="failed on setup with &quot;RuntimeError: There is no current event loop in thread 'MainThread'.&quot;">self = &lt;test_adapter_registry.TestAdapterRegistry object at 0x7fa365c89c40&gt;

    @pytest.fixture
    def registry(self):
        """创建注册中心实例"""
&gt;       return AdapterRegistry()

tests/unit/adapters/test_adapter_registry.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</error></testcase><testcase classname="unit.adapters.test_adapter_registry.TestEventBus" name="test_event_bus_initialization" time="0.489"><failure message="TypeError: isinstance() arg 2 must be a type or tuple of types">self = &lt;test_adapter_registry.TestEventBus object at 0x7fa365c18d60&gt;
event_bus = &lt;zishu.adapters.base.registry.EventBus object at 0x7fa35d917250&gt;

    def test_event_bus_initialization(self, event_bus):
        """测试事件总线初始化"""
        assert len(event_bus._listeners) == 0
&gt;       assert isinstance(event_bus._lock, threading.RLock)
E       TypeError: isinstance() arg 2 must be a type or tuple of types

tests/unit/adapters/test_adapter_registry.py:333: TypeError</failure></testcase><testcase classname="unit.adapters.test_adapter_registry.TestEventBus" name="test_subscribe_and_publish" time="0.504"><failure message="AttributeError: 'EventBus' object has no attribute 'publish'">self = &lt;test_adapter_registry.TestEventBus object at 0x7fa365c18fd0&gt;
event_bus = &lt;zishu.adapters.base.registry.EventBus object at 0x7fa35d74c8b0&gt;

    def test_subscribe_and_publish(self, event_bus):
        """测试订阅和发布事件"""
        received_events = []
    
        def event_handler(event):
            received_events.append(event)
    
        # 订阅事件
        event_bus.subscribe(EventType.ADAPTER_REGISTERED, event_handler)
    
        # 发布事件
        event = RegistryEvent(
            event_type=EventType.ADAPTER_REGISTERED,
            adapter_id="test-adapter",
            timestamp=datetime.now(timezone.utc)
        )
&gt;       event_bus.publish(event)
E       AttributeError: 'EventBus' object has no attribute 'publish'

tests/unit/adapters/test_adapter_registry.py:351: AttributeError</failure></testcase><testcase classname="unit.adapters.test_adapter_registry.TestEventBus" name="test_unsubscribe" time="0.481"><failure message="AttributeError: 'EventBus' object has no attribute 'publish'">self = &lt;test_adapter_registry.TestEventBus object at 0x7fa365c1f2b0&gt;
event_bus = &lt;zishu.adapters.base.registry.EventBus object at 0x7fa35d741b20&gt;

    def test_unsubscribe(self, event_bus):
        """测试取消订阅"""
        received_events = []
    
        def event_handler(event):
            received_events.append(event)
    
        # 订阅
        event_bus.subscribe(EventType.ADAPTER_REGISTERED, event_handler)
    
        # 发布事件
        event = RegistryEvent(
            event_type=EventType.ADAPTER_REGISTERED,
            adapter_id="test-adapter",
            timestamp=datetime.now(timezone.utc)
        )
&gt;       event_bus.publish(event)
E       AttributeError: 'EventBus' object has no attribute 'publish'

tests/unit/adapters/test_adapter_registry.py:373: AttributeError</failure></testcase><testcase classname="unit.adapters.test_adapter_registry.TestEventBus" name="test_multiple_listeners" time="0.579"><failure message="AttributeError: 'EventBus' object has no attribute 'publish'">self = &lt;test_adapter_registry.TestEventBus object at 0x7fa365c1f550&gt;
event_bus = &lt;zishu.adapters.base.registry.EventBus object at 0x7fa35dae9a30&gt;

    def test_multiple_listeners(self, event_bus):
        """测试多个监听器"""
        received_events_1 = []
        received_events_2 = []
    
        def handler_1(event):
            received_events_1.append(event)
    
        def handler_2(event):
            received_events_2.append(event)
    
        # 订阅多个处理器
        event_bus.subscribe(EventType.ADAPTER_REGISTERED, handler_1)
        event_bus.subscribe(EventType.ADAPTER_REGISTERED, handler_2)
    
        # 发布事件
        event = RegistryEvent(
            event_type=EventType.ADAPTER_REGISTERED,
            adapter_id="test-adapter",
            timestamp=datetime.now(timezone.utc)
        )
&gt;       event_bus.publish(event)
E       AttributeError: 'EventBus' object has no attribute 'publish'

tests/unit/adapters/test_adapter_registry.py:404: AttributeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestErrorHandlerMiddleware" name="test_error_handler_validation_error" time="0.489"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestErrorHandlerMiddleware object at 0x7fa35de43250&gt;
mock_logger = &lt;Mock id='140339623279968'&gt;

    def test_error_handler_validation_error(self, mock_logger):
        """测试验证错误处理"""
        app = FastAPI()
        app.add_middleware(ErrorHandlerMiddleware, logger=mock_logger)
    
        from pydantic import BaseModel
    
        class TestModel(BaseModel):
            name: str
            age: int
    
        @app.post("/test")
        async def test_endpoint(data: TestModel):
            return {"received": data.dict()}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d64b400&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d64bd30&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestErrorHandlerMiddleware" name="test_error_handler_unexpected_exception" time="0.428"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestErrorHandlerMiddleware object at 0x7fa35de4b820&gt;
mock_logger = &lt;Mock id='140339623188704'&gt;

    def test_error_handler_unexpected_exception(self, mock_logger):
        """测试意外异常处理"""
        app = FastAPI()
        app.add_middleware(ErrorHandlerMiddleware, logger=mock_logger)
    
        @app.get("/test")
        async def test_endpoint():
            raise ValueError("Unexpected error")
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d635d30&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d635700&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestErrorHandlerMiddleware" name="test_error_handler_with_request_id" time="0.390"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestErrorHandlerMiddleware object at 0x7fa35de4ba90&gt;
mock_logger = &lt;Mock id='140339625608672'&gt;

    def test_error_handler_with_request_id(self, mock_logger):
        """测试带请求ID的错误处理"""
        app = FastAPI()
        app.add_middleware(ErrorHandlerMiddleware, logger=mock_logger, include_request_id=True)
    
        @app.get("/test")
        async def test_endpoint():
            raise ValueError("Test error")
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d884ac0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d884970&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestErrorHandlerMiddleware" name="test_error_handler_http_exception" time="0.402"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestErrorHandlerMiddleware object at 0x7fa35de4b580&gt;
mock_logger = &lt;Mock id='140339623188848'&gt;

    def test_error_handler_http_exception(self, mock_logger):
        """测试HTTP异常处理"""
        app = FastAPI()
        app.add_middleware(ErrorHandlerMiddleware, logger=mock_logger)
    
        @app.get("/test")
        async def test_endpoint():
            raise HTTPException(status_code=404, detail="Not found")
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d635400&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d635190&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestSecurityMiddleware" name="test_security_middleware_headers" time="0.575"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestSecurityMiddleware object at 0x7fa35de3c2e0&gt;

    def test_security_middleware_headers(self):
        """测试安全头设置"""
        app = FastAPI()
        app.add_middleware(SecurityMiddleware)
    
        @app.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d884ac0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d884be0&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestSecurityMiddleware" name="test_security_middleware_hsts_header" time="0.334"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestSecurityMiddleware object at 0x7fa35de3c7c0&gt;

    def test_security_middleware_hsts_header(self):
        """测试HSTS头"""
        app = FastAPI()
        app.add_middleware(SecurityMiddleware, enable_hsts=True)
    
        @app.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d6354f0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d635790&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestSecurityMiddleware" name="test_security_middleware_csp_header" time="0.380"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestSecurityMiddleware object at 0x7fa35de3c550&gt;

    def test_security_middleware_csp_header(self):
        """测试内容安全策略头"""
        app = FastAPI()
        app.add_middleware(SecurityMiddleware, enable_csp=True)
    
        @app.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d884790&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d884be0&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestMiddlewareChain" name="test_middleware_response_modification" time="0.403"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestMiddlewareChain object at 0x7fa35de4be80&gt;

    def test_middleware_response_modification(self):
        """测试中间件修改响应"""
        app = FastAPI()
    
        class ResponseModifierMiddleware(BaseHTTPMiddleware):
            async def dispatch(self, request: Request, call_next):
                response = await call_next(request)
                response.headers["X-Custom-Response"] = "modified"
                return response
    
        app.add_middleware(ResponseModifierMiddleware)
    
        @app.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:527: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d884460&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d64bdf0&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestMiddlewareChain" name="test_middleware_execution_order" time="0.602"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestMiddlewareChain object at 0x7fa35de4b610&gt;

    def test_middleware_execution_order(self):
        """测试中间件执行顺序"""
        app = FastAPI()
        execution_order = []
    
        class FirstMiddleware(BaseHTTPMiddleware):
            async def dispatch(self, request: Request, call_next):
                execution_order.append("first_start")
                response = await call_next(request)
                execution_order.append("first_end")
                return response
    
        class SecondMiddleware(BaseHTTPMiddleware):
            async def dispatch(self, request: Request, call_next):
                execution_order.append("second_start")
                response = await call_next(request)
                execution_order.append("second_end")
                return response
    
        app.add_middleware(FirstMiddleware)
        app.add_middleware(SecondMiddleware)
    
        @app.get("/test")
        async def test_endpoint():
            execution_order.append("endpoint")
            return {"message": "test"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:476: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35da6f760&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d884340&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestMiddlewareChain" name="test_middleware_request_modification" time="0.479"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestMiddlewareChain object at 0x7fa35de4bc40&gt;

    def test_middleware_request_modification(self):
        """测试中间件修改请求"""
        app = FastAPI()
    
        class RequestModifierMiddleware(BaseHTTPMiddleware):
            async def dispatch(self, request: Request, call_next):
                # 添加自定义头
                request.headers.__dict__["_list"].append(
                    (b"x-custom-header", b"custom-value")
                )
                return await call_next(request)
    
        app.add_middleware(RequestModifierMiddleware)
    
        @app.get("/test")
        async def test_endpoint(request: Request):
            return {"custom_header": request.headers.get("x-custom-header")}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:505: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d64b400&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d635cd0&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestLoggingMiddleware" name="test_logging_middleware_error" time="0.421"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestLoggingMiddleware object at 0x7fa35de43b80&gt;
mock_logger = &lt;Mock id='140339625611168'&gt;

    def test_logging_middleware_error(self, mock_logger):
        """测试错误请求的日志记录"""
        app = FastAPI()
        app.add_middleware(LoggingMiddleware, logger=mock_logger)
    
        @app.get("/test")
        async def test_endpoint():
            raise HTTPException(status_code=500, detail="Internal error")
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d9f9fa0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d884fd0&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestLoggingMiddleware" name="test_request_logging_middleware_sensitive_data" time="0.480"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestLoggingMiddleware object at 0x7fa35de436a0&gt;
mock_logger = &lt;Mock id='140339623279392'&gt;

    def test_request_logging_middleware_sensitive_data(self, mock_logger):
        """测试敏感数据过滤"""
        app = FastAPI()
        app.add_middleware(
            RequestLoggingMiddleware,
            logger=mock_logger,
            log_body=True,
            sensitive_fields=["password", "token"]
        )
    
        @app.post("/test")
        async def test_endpoint(data: dict):
            return {"received": "ok"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d6359d0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d64b220&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestLoggingMiddleware" name="test_logging_middleware_success" time="0.330"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestLoggingMiddleware object at 0x7fa35de439a0&gt;
mock_logger = &lt;Mock id='140339625608528'&gt;

    def test_logging_middleware_success(self, mock_logger):
        """测试成功请求的日志记录"""
        app = FastAPI()
        app.add_middleware(LoggingMiddleware, logger=mock_logger)
    
        @app.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d715190&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d884970&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestLoggingMiddleware" name="test_request_logging_middleware_with_body" time="0.391"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestLoggingMiddleware object at 0x7fa35de43df0&gt;
mock_logger = &lt;Mock id='140339623279392'&gt;

    def test_request_logging_middleware_with_body(self, mock_logger):
        """测试带请求体的日志记录"""
        app = FastAPI()
        app.add_middleware(RequestLoggingMiddleware, logger=mock_logger, log_body=True)
    
        @app.post("/test")
        async def test_endpoint(data: dict):
            return {"received": data}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35db3df10&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d64bf40&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestMiddlewarePerformance" name="test_rate_limit_performance" time="0.403"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestMiddlewarePerformance object at 0x7fa35de54c40&gt;

    def test_rate_limit_performance(self):
        """测试速率限制性能"""
        app = FastAPI()
        app.add_middleware(RateLimitMiddleware, calls=1000, period=60)
    
        @app.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:651: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35dbb03d0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d884430&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestMiddlewarePerformance" name="test_middleware_overhead" time="0.440"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestMiddlewarePerformance object at 0x7fa35de549d0&gt;

    def test_middleware_overhead(self):
        """测试中间件开销"""
        # 无中间件的应用
        app_no_middleware = FastAPI()
    
        @app_no_middleware.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
        # 有中间件的应用
        app_with_middleware = FastAPI()
        mock_logger = Mock()
    
        setup_cors(app_with_middleware)
        app_with_middleware.add_middleware(SecurityMiddleware)
        app_with_middleware.add_middleware(LoggingMiddleware, logger=mock_logger)
    
        @app_with_middleware.get("/test")
        async def test_endpoint_with_middleware():
            return {"message": "test"}
    
&gt;       client_no_middleware = TestClient(app_no_middleware)

tests/unit/api/test_server_middleware.py:621: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35db2ac40&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35db3d790&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestMiddlewareIntegration" name="test_middleware_with_async_endpoints" time="0.334"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestMiddlewareIntegration object at 0x7fa35de54550&gt;

    def test_middleware_with_async_endpoints(self):
        """测试中间件与异步端点"""
        app = FastAPI()
        mock_logger = Mock()
    
        app.add_middleware(LoggingMiddleware, logger=mock_logger)
    
        @app.get("/async")
        async def async_endpoint():
            await asyncio.sleep(0.01)  # 模拟异步操作
            return {"message": "async"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:587: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d635b50&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35dbb0340&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestMiddlewareIntegration" name="test_full_middleware_stack" time="0.380"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestMiddlewareIntegration object at 0x7fa35de542e0&gt;

    def test_full_middleware_stack(self):
        """测试完整中间件栈"""
        app = FastAPI()
        mock_logger = Mock()
    
        # 添加所有中间件
        setup_cors(app)
        app.add_middleware(SecurityMiddleware)
        app.add_middleware(RateLimitMiddleware, calls=10, period=60)
        app.add_middleware(LoggingMiddleware, logger=mock_logger)
        app.add_middleware(ErrorHandlerMiddleware, logger=mock_logger)
    
        @app.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
        @app.get("/error")
        async def error_endpoint():
            raise ValueError("Test error")
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35db2a2e0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d64b070&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestRateLimitMiddleware" name="test_rate_limit_different_clients" time="0.397"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestRateLimitMiddleware object at 0x7fa35de431c0&gt;
rate_limit_app = &lt;fastapi.applications.FastAPI object at 0x7fa35d884a30&gt;

    def test_rate_limit_different_clients(self, rate_limit_app):
        """测试不同客户端的速率限制"""
&gt;       client = TestClient(rate_limit_app)

tests/unit/api/test_server_middleware.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35dbb0d00&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d884a30&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestRateLimitMiddleware" name="test_rate_limit_within_limit" time="0.413"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestRateLimitMiddleware object at 0x7fa35de3cca0&gt;
rate_limit_app = &lt;fastapi.applications.FastAPI object at 0x7fa35db2a400&gt;

    def test_rate_limit_within_limit(self, rate_limit_app):
        """测试在限制范围内的请求"""
&gt;       client = TestClient(rate_limit_app)

tests/unit/api/test_server_middleware.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35db3da90&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35db2a400&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestRateLimitMiddleware" name="test_rate_limit_exceeded" time="0.398"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestRateLimitMiddleware object at 0x7fa35de3cf10&gt;
rate_limit_app = &lt;fastapi.applications.FastAPI object at 0x7fa35dbb0a30&gt;

    def test_rate_limit_exceeded(self, rate_limit_app):
        """测试超出速率限制"""
&gt;       client = TestClient(rate_limit_app)

tests/unit/api/test_server_middleware.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d884f70&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35dbb0a30&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestRateLimitMiddleware" name="test_rate_limit_reset_after_period" time="0.395"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestRateLimitMiddleware object at 0x7fa35de43430&gt;
mock_time = &lt;MagicMock name='time' id='140339628386720'&gt;
rate_limit_app = &lt;fastapi.applications.FastAPI object at 0x7fa35db3d040&gt;

    @patch('time.time')
    def test_rate_limit_reset_after_period(self, mock_time, rate_limit_app):
        """测试时间窗口重置后的速率限制"""
&gt;       client = TestClient(rate_limit_app)

tests/unit/api/test_server_middleware.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35db2a400&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35db3d040&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestCORSMiddleware" name="test_setup_cors_default" time="0.384" /><testcase classname="unit.api.test_server_middleware.TestCORSMiddleware" name="test_cors_actual_request" time="0.337"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestCORSMiddleware object at 0x7fa35de3c070&gt;

    def test_cors_actual_request(self):
        """测试实际CORS请求"""
        app = FastAPI()
        setup_cors(app)
    
        @app.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35d6b4160&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35d6b4910&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestCORSMiddleware" name="test_cors_preflight_request" time="0.389"><failure message="TypeError: __init__() got an unexpected keyword argument 'app'">self = &lt;test_server_middleware.TestCORSMiddleware object at 0x7fa35de33dc0&gt;

    def test_cors_preflight_request(self):
        """测试CORS预检请求"""
        app = FastAPI()
        setup_cors(app)
    
        @app.get("/test")
        async def test_endpoint():
            return {"message": "test"}
    
&gt;       client = TestClient(app)

tests/unit/api/test_server_middleware.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x7fa35da2ec10&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7fa35da2e850&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: __init__() got an unexpected keyword argument 'app'

/root/miniconda3/lib/python3.8/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="unit.api.test_server_middleware.TestCORSMiddleware" name="test_setup_cors_custom_origins" time="0.376"><failure message="TypeError: setup_cors() got an unexpected keyword argument 'allowed_origins'">self = &lt;test_server_middleware.TestCORSMiddleware object at 0x7fa35de33b50&gt;

    def test_setup_cors_custom_origins(self):
        """测试自定义CORS源设置"""
        app = FastAPI()
        custom_origins = ["http://localhost:3000", "https://example.com"]
&gt;       setup_cors(app, allowed_origins=custom_origins)
E       TypeError: setup_cors() got an unexpected keyword argument 'allowed_origins'

tests/unit/api/test_server_middleware.py:51: TypeError</failure></testcase><testcase classname="unit.models.test_inference.TestModelPerformance" name="test_memory_efficiency" time="0.488"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 412&#10;      def test_memory_efficiency(self, mock_inference_engine, performance_monitor):&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:412&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 412
      def test_memory_efficiency(self, mock_inference_engine, performance_monitor):
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:412</error></testcase><testcase classname="unit.models.test_inference.TestModelPerformance" name="test_batch_processing_efficiency" time="0.331"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 428&#10;      def test_batch_processing_efficiency(self, mock_inference_engine):&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:428&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 428
      def test_batch_processing_efficiency(self, mock_inference_engine):
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:428</error></testcase><testcase classname="unit.models.test_inference.TestModelPerformance" name="test_concurrent_generation" time="0.423"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 446&#10;      def test_concurrent_generation(self, mock_inference_engine):&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:446&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 446
      def test_concurrent_generation(self, mock_inference_engine):
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:446</error></testcase><testcase classname="unit.models.test_inference.TestModelPerformance" name="test_generation_speed" time="0.469"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 397&#10;      @pytest.mark.asyncio&#10;      async def test_generation_speed(self, mock_inference_engine, performance_monitor):&#10;          &quot;&quot;&quot;测试生成速度&quot;&quot;&quot;&#10;          performance_monitor.start()&#10;&#10;          # 模拟快速生成&#10;          mock_inference_engine.generate = AsyncMock(return_value=&quot;快速生成的回复&quot;)&#10;&#10;          result = await mock_inference_engine.generate(&quot;测试输入&quot;)&#10;&#10;          metrics = performance_monitor.stop()&#10;&#10;          assert result == &quot;快速生成的回复&quot;&#10;          assert metrics[&quot;duration&quot;] &lt; 2.0  # 生成应该在2秒内完成&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:397&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 397
      @pytest.mark.asyncio
      async def test_generation_speed(self, mock_inference_engine, performance_monitor):
          """测试生成速度"""
          performance_monitor.start()

          # 模拟快速生成
          mock_inference_engine.generate = AsyncMock(return_value="快速生成的回复")

          result = await mock_inference_engine.generate("测试输入")

          metrics = performance_monitor.stop()

          assert result == "快速生成的回复"
          assert metrics["duration"] &lt; 2.0  # 生成应该在2秒内完成
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:397</error></testcase><testcase classname="unit.models.test_inference.TestModelLoader" name="test_load_from_path" time="0.474"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_load_from_path&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.models.test_inference.TestModelLoader" name="test_model_loader_initialization" time="0.402" /><testcase classname="unit.models.test_inference.TestModelLoader" name="test_validate_model_format" time="0.424" /><testcase classname="unit.models.test_inference.TestModelLoader" name="test_model_caching" time="0.387" /><testcase classname="unit.models.test_inference.TestModelLoader" name="test_load_from_hub" time="0.479"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_load_from_hub&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.models.test_inference.TestModelIntegration" name="test_model_with_adapter" time="0.389"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 373&#10;      @pytest.mark.asyncio&#10;      async def test_model_with_adapter(self, mock_inference_engine, mock_adapter_manager):&#10;          &quot;&quot;&quot;测试模型与适配器集成&quot;&quot;&quot;&#10;          # 模拟加载适配器&#10;          await mock_adapter_manager.load_adapter(&quot;emotion_adapter&quot;, &quot;/path/to/adapter&quot;)&#10;&#10;          # 模拟带适配器的生成&#10;          mock_inference_engine.generate_with_adapter = AsyncMock(&#10;              return_value=&quot;我现在感到很开心～（带有情绪适配器的回复）&quot;&#10;          )&#10;&#10;          result = await mock_inference_engine.generate_with_adapter(&#10;              prompt=&quot;今天天气真好&quot;,&#10;              adapter_name=&quot;emotion_adapter&quot;&#10;          )&#10;&#10;          assert &quot;开心&quot; in result&#10;          mock_inference_engine.generate_with_adapter.assert_called_once()&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:373&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 373
      @pytest.mark.asyncio
      async def test_model_with_adapter(self, mock_inference_engine, mock_adapter_manager):
          """测试模型与适配器集成"""
          # 模拟加载适配器
          await mock_adapter_manager.load_adapter("emotion_adapter", "/path/to/adapter")

          # 模拟带适配器的生成
          mock_inference_engine.generate_with_adapter = AsyncMock(
              return_value="我现在感到很开心～（带有情绪适配器的回复）"
          )

          result = await mock_inference_engine.generate_with_adapter(
              prompt="今天天气真好",
              adapter_name="emotion_adapter"
          )

          assert "开心" in result
          mock_inference_engine.generate_with_adapter.assert_called_once()
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:373</error></testcase><testcase classname="unit.models.test_inference.TestModelIntegration" name="test_end_to_end_generation" time="0.314"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 335&#10;      @pytest.mark.asyncio&#10;      async def test_end_to_end_generation(self, mock_inference_engine):&#10;          &quot;&quot;&quot;测试端到端生成&quot;&quot;&quot;&#10;          # 模拟完整的生成流程&#10;          input_text = &quot;用户：你好，紫舒！\n紫舒：&quot;&#10;          expected_output = &quot;你好！很高兴见到你～今天有什么我可以帮助你的吗？&quot;&#10;&#10;          # 设置mock行为&#10;          mock_inference_engine.tokenizer.encode.return_value = [1, 100, 200, 300]&#10;          mock_inference_engine.model.generate.return_value = torch.tensor([[1, 100, 200, 300, 400, 500, 600]])&#10;          mock_inference_engine.tokenizer.decode.return_value = expected_output&#10;          mock_inference_engine.generate = AsyncMock(return_value=expected_output)&#10;&#10;          # 执行生成&#10;          result = await mock_inference_engine.generate(input_text)&#10;&#10;          assert result == expected_output&#10;          mock_inference_engine.generate.assert_called_once_with(input_text)&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:335&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 335
      @pytest.mark.asyncio
      async def test_end_to_end_generation(self, mock_inference_engine):
          """测试端到端生成"""
          # 模拟完整的生成流程
          input_text = "用户：你好，紫舒！\n紫舒："
          expected_output = "你好！很高兴见到你～今天有什么我可以帮助你的吗？"

          # 设置mock行为
          mock_inference_engine.tokenizer.encode.return_value = [1, 100, 200, 300]
          mock_inference_engine.model.generate.return_value = torch.tensor([[1, 100, 200, 300, 400, 500, 600]])
          mock_inference_engine.tokenizer.decode.return_value = expected_output
          mock_inference_engine.generate = AsyncMock(return_value=expected_output)

          # 执行生成
          result = await mock_inference_engine.generate(input_text)

          assert result == expected_output
          mock_inference_engine.generate.assert_called_once_with(input_text)
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:335</error></testcase><testcase classname="unit.models.test_inference.TestModelIntegration" name="test_conversation_context" time="0.374"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 354&#10;      @pytest.mark.asyncio&#10;      async def test_conversation_context(self, mock_inference_engine):&#10;          &quot;&quot;&quot;测试对话上下文&quot;&quot;&quot;&#10;          conversation_history = [&#10;              &quot;用户：我叫小明&quot;,&#10;              &quot;紫舒：你好小明！很高兴认识你&quot;,&#10;              &quot;用户：你还记得我的名字吗？&quot;,&#10;          ]&#10;&#10;          context = &quot;\n&quot;.join(conversation_history) + &quot;\n紫舒：&quot;&#10;          expected_response = &quot;当然记得！你是小明呀～&quot;&#10;&#10;          mock_inference_engine.generate = AsyncMock(return_value=expected_response)&#10;&#10;          result = await mock_inference_engine.generate(context)&#10;&#10;          assert &quot;小明&quot; in result or result == expected_response&#10;          mock_inference_engine.generate.assert_called_once_with(context)&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:354&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 354
      @pytest.mark.asyncio
      async def test_conversation_context(self, mock_inference_engine):
          """测试对话上下文"""
          conversation_history = [
              "用户：我叫小明",
              "紫舒：你好小明！很高兴认识你",
              "用户：你还记得我的名字吗？",
          ]

          context = "\n".join(conversation_history) + "\n紫舒："
          expected_response = "当然记得！你是小明呀～"

          mock_inference_engine.generate = AsyncMock(return_value=expected_response)

          result = await mock_inference_engine.generate(context)

          assert "小明" in result or result == expected_response
          mock_inference_engine.generate.assert_called_once_with(context)
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:354</error></testcase><testcase classname="unit.models.test_inference.TestModelErrorHandling" name="test_generation_timeout" time="0.315"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 517&#10;      @pytest.mark.asyncio&#10;      async def test_generation_timeout(self, mock_inference_engine):&#10;          &quot;&quot;&quot;测试生成超时&quot;&quot;&quot;&#10;          async def slow_generate(*args, **kwargs):&#10;              await asyncio.sleep(10)  # 模拟慢速生成&#10;              return &quot;超时测试&quot;&#10;&#10;          mock_inference_engine.generate = slow_generate&#10;&#10;          with pytest.raises(asyncio.TimeoutError):&#10;              await asyncio.wait_for(&#10;                  mock_inference_engine.generate(&quot;测试输入&quot;),&#10;                  timeout=1.0&#10;              )&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:517&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 517
      @pytest.mark.asyncio
      async def test_generation_timeout(self, mock_inference_engine):
          """测试生成超时"""
          async def slow_generate(*args, **kwargs):
              await asyncio.sleep(10)  # 模拟慢速生成
              return "超时测试"

          mock_inference_engine.generate = slow_generate

          with pytest.raises(asyncio.TimeoutError):
              await asyncio.wait_for(
                  mock_inference_engine.generate("测试输入"),
                  timeout=1.0
              )
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:517</error></testcase><testcase classname="unit.models.test_inference.TestModelErrorHandling" name="test_invalid_generation_config" time="0.486"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 489&#10;      def test_invalid_generation_config(self, mock_inference_engine):&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:489&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 489
      def test_invalid_generation_config(self, mock_inference_engine):
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:489</error></testcase><testcase classname="unit.models.test_inference.TestModelErrorHandling" name="test_tokenization_error" time="0.312"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 508&#10;      def test_tokenization_error(self, mock_inference_engine):&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:508&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 508
      def test_tokenization_error(self, mock_inference_engine):
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:508</error></testcase><testcase classname="unit.models.test_inference.TestModelErrorHandling" name="test_out_of_memory_error" time="0.370"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 479&#10;      @pytest.mark.asyncio&#10;      async def test_out_of_memory_error(self, mock_inference_engine):&#10;          &quot;&quot;&quot;测试内存不足错误&quot;&quot;&quot;&#10;          mock_inference_engine.generate = AsyncMock(&#10;              side_effect=RuntimeError(&quot;CUDA out of memory&quot;)&#10;          )&#10;&#10;          with pytest.raises(RuntimeError, match=&quot;CUDA out of memory&quot;):&#10;              await mock_inference_engine.generate(&quot;测试输入&quot;)&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:479&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 479
      @pytest.mark.asyncio
      async def test_out_of_memory_error(self, mock_inference_engine):
          """测试内存不足错误"""
          mock_inference_engine.generate = AsyncMock(
              side_effect=RuntimeError("CUDA out of memory")
          )

          with pytest.raises(RuntimeError, match="CUDA out of memory"):
              await mock_inference_engine.generate("测试输入")
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:479</error></testcase><testcase classname="unit.models.test_inference.TestModelErrorHandling" name="test_model_loading_failure" time="0.421"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 469&#10;      @pytest.mark.asyncio&#10;      async def test_model_loading_failure(self, mock_inference_engine):&#10;          &quot;&quot;&quot;测试模型加载失败&quot;&quot;&quot;&#10;          mock_inference_engine.load_model = AsyncMock(&#10;              side_effect=FileNotFoundError(&quot;模型文件不存在&quot;)&#10;          )&#10;&#10;          with pytest.raises(FileNotFoundError, match=&quot;模型文件不存在&quot;):&#10;              await mock_inference_engine.load_model(&quot;/nonexistent/model&quot;)&#10;E       fixture 'mock_inference_engine' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:469&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 469
      @pytest.mark.asyncio
      async def test_model_loading_failure(self, mock_inference_engine):
          """测试模型加载失败"""
          mock_inference_engine.load_model = AsyncMock(
              side_effect=FileNotFoundError("模型文件不存在")
          )

          with pytest.raises(FileNotFoundError, match="模型文件不存在"):
              await mock_inference_engine.load_model("/nonexistent/model")
E       fixture 'mock_inference_engine' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestModelErrorHandling::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:469</error></testcase><testcase classname="unit.models.test_inference.TestGenerationStrategies" name="test_temperature_scaling" time="0.402" /><testcase classname="unit.models.test_inference.TestGenerationStrategies" name="test_sampling_generation" time="0.321"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 258&#10;      def test_sampling_generation(self, mock_model):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestGenerationStrategies::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:258&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 258
      def test_sampling_generation(self, mock_model):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestGenerationStrategies::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:258</error></testcase><testcase classname="unit.models.test_inference.TestGenerationStrategies" name="test_greedy_generation" time="0.398"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 238&#10;      def test_greedy_generation(self, mock_model):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestGenerationStrategies::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:238&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 238
      def test_greedy_generation(self, mock_model):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestGenerationStrategies::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:238</error></testcase><testcase classname="unit.models.test_inference.TestGenerationStrategies" name="test_beam_search_generation" time="0.386"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 277&#10;      def test_beam_search_generation(self, mock_model):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestGenerationStrategies::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:277&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 277
      def test_beam_search_generation(self, mock_model):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestGenerationStrategies::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:277</error></testcase><testcase classname="unit.models.test_inference.TestGenerationStrategies" name="test_top_p_filtering" time="0.388" /><testcase classname="unit.models.test_inference.TestInferenceEngine" name="test_unload_model" time="0.992"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 70&#10;      @pytest.mark.asyncio&#10;      async def test_unload_model(self, mock_inference_engine):&#10;          &quot;&quot;&quot;测试模型卸载&quot;&quot;&quot;&#10;          mock_inference_engine.unload_model = AsyncMock(return_value=True)&#10;          mock_inference_engine.is_loaded = False&#10;&#10;          result = await mock_inference_engine.unload_model()&#10;&#10;          assert result is True&#10;          assert mock_inference_engine.is_loaded is False&#10;          mock_inference_engine.unload_model.assert_called_once()&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22&#10;      @pytest.fixture&#10;      def mock_inference_engine(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 70
      @pytest.mark.asyncio
      async def test_unload_model(self, mock_inference_engine):
          """测试模型卸载"""
          mock_inference_engine.unload_model = AsyncMock(return_value=True)
          mock_inference_engine.is_loaded = False

          result = await mock_inference_engine.unload_model()

          assert result is True
          assert mock_inference_engine.is_loaded is False
          mock_inference_engine.unload_model.assert_called_once()
file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22
      @pytest.fixture
      def mock_inference_engine(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22</error></testcase><testcase classname="unit.models.test_inference.TestInferenceEngine" name="test_batch_generation" time="0.332"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 98&#10;      @pytest.mark.asyncio&#10;      async def test_batch_generation(self, mock_inference_engine):&#10;          &quot;&quot;&quot;测试批量生成&quot;&quot;&quot;&#10;          input_prompts = [&#10;              &quot;你好，紫舒&quot;,&#10;              &quot;今天天气怎么样？&quot;,&#10;              &quot;你能帮我做什么？&quot;&#10;          ]&#10;          expected_outputs = [&#10;              &quot;你好！很高兴见到你～&quot;,&#10;              &quot;今天天气很好呢！&quot;,&#10;              &quot;我可以帮你聊天、回答问题等～&quot;&#10;          ]&#10;&#10;          mock_inference_engine.batch_generate = AsyncMock(return_value=expected_outputs)&#10;&#10;          results = await mock_inference_engine.batch_generate(input_prompts)&#10;&#10;          assert len(results) == 3&#10;          assert results == expected_outputs&#10;          mock_inference_engine.batch_generate.assert_called_once_with(input_prompts)&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22&#10;      @pytest.fixture&#10;      def mock_inference_engine(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 98
      @pytest.mark.asyncio
      async def test_batch_generation(self, mock_inference_engine):
          """测试批量生成"""
          input_prompts = [
              "你好，紫舒",
              "今天天气怎么样？",
              "你能帮我做什么？"
          ]
          expected_outputs = [
              "你好！很高兴见到你～",
              "今天天气很好呢！",
              "我可以帮你聊天、回答问题等～"
          ]

          mock_inference_engine.batch_generate = AsyncMock(return_value=expected_outputs)

          results = await mock_inference_engine.batch_generate(input_prompts)

          assert len(results) == 3
          assert results == expected_outputs
          mock_inference_engine.batch_generate.assert_called_once_with(input_prompts)
file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22
      @pytest.fixture
      def mock_inference_engine(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22</error></testcase><testcase classname="unit.models.test_inference.TestInferenceEngine" name="test_load_model" time="0.310"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 58&#10;      @pytest.mark.asyncio&#10;      async def test_load_model(self, mock_inference_engine):&#10;          &quot;&quot;&quot;测试模型加载&quot;&quot;&quot;&#10;          mock_inference_engine.load_model = AsyncMock(return_value=True)&#10;          mock_inference_engine.is_loaded = True&#10;&#10;          result = await mock_inference_engine.load_model(&quot;test_model_path&quot;)&#10;&#10;          assert result is True&#10;          assert mock_inference_engine.is_loaded is True&#10;          mock_inference_engine.load_model.assert_called_once_with(&quot;test_model_path&quot;)&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22&#10;      @pytest.fixture&#10;      def mock_inference_engine(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 58
      @pytest.mark.asyncio
      async def test_load_model(self, mock_inference_engine):
          """测试模型加载"""
          mock_inference_engine.load_model = AsyncMock(return_value=True)
          mock_inference_engine.is_loaded = True

          result = await mock_inference_engine.load_model("test_model_path")

          assert result is True
          assert mock_inference_engine.is_loaded is True
          mock_inference_engine.load_model.assert_called_once_with("test_model_path")
file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22
      @pytest.fixture
      def mock_inference_engine(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22</error></testcase><testcase classname="unit.models.test_inference.TestInferenceEngine" name="test_detokenization" time="0.400"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 132&#10;      def test_detokenization(self, mock_inference_engine):&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22&#10;      @pytest.fixture&#10;      def mock_inference_engine(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 132
      def test_detokenization(self, mock_inference_engine):
file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22
      @pytest.fixture
      def mock_inference_engine(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22</error></testcase><testcase classname="unit.models.test_inference.TestInferenceEngine" name="test_tokenization" time="0.393"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 120&#10;      def test_tokenization(self, mock_inference_engine):&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22&#10;      @pytest.fixture&#10;      def mock_inference_engine(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 120
      def test_tokenization(self, mock_inference_engine):
file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22
      @pytest.fixture
      def mock_inference_engine(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22</error></testcase><testcase classname="unit.models.test_inference.TestInferenceEngine" name="test_generate_text" time="0.400"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 82&#10;      @pytest.mark.asyncio&#10;      async def test_generate_text(self, mock_inference_engine, sample_generation_config):&#10;          &quot;&quot;&quot;测试文本生成&quot;&quot;&quot;&#10;          input_text = &quot;你好，我是紫舒&quot;&#10;          expected_output = &quot;你好，我是紫舒！很高兴认识你～&quot;&#10;&#10;          mock_inference_engine.generate = AsyncMock(return_value=expected_output)&#10;&#10;          result = await mock_inference_engine.generate(&#10;              prompt=input_text,&#10;              **sample_generation_config&#10;          )&#10;&#10;          assert result == expected_output&#10;          mock_inference_engine.generate.assert_called_once()&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22&#10;      @pytest.fixture&#10;      def mock_inference_engine(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 82
      @pytest.mark.asyncio
      async def test_generate_text(self, mock_inference_engine, sample_generation_config):
          """测试文本生成"""
          input_text = "你好，我是紫舒"
          expected_output = "你好，我是紫舒！很高兴认识你～"

          mock_inference_engine.generate = AsyncMock(return_value=expected_output)

          result = await mock_inference_engine.generate(
              prompt=input_text,
              **sample_generation_config
          )

          assert result == expected_output
          mock_inference_engine.generate.assert_called_once()
file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22
      @pytest.fixture
      def mock_inference_engine(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22</error></testcase><testcase classname="unit.models.test_inference.TestInferenceEngine" name="test_inference_engine_initialization" time="0.319"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 50&#10;      def test_inference_engine_initialization(self, mock_inference_engine):&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22&#10;      @pytest.fixture&#10;      def mock_inference_engine(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 50
      def test_inference_engine_initialization(self, mock_inference_engine):
file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22
      @pytest.fixture
      def mock_inference_engine(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22</error></testcase><testcase classname="unit.models.test_inference.TestInferenceEngine" name="test_model_info" time="0.380"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 144&#10;      def test_model_info(self, mock_inference_engine):&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22&#10;      @pytest.fixture&#10;      def mock_inference_engine(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 144
      def test_model_info(self, mock_inference_engine):
file /root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py, line 22
      @pytest.fixture
      def mock_inference_engine(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_inference_engine, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, sample_generation_config, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/models/test_inference.py::&lt;event_loop&gt;, unit/models/test_inference.py::TestInferenceEngine::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/models/test_inference.py:22</error></testcase><testcase classname="unit.api.test_chat_api.TestAPIPerformance" name="test_concurrent_chat_requests" time="0.336"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_concurrent_chat_requests&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_api.TestAPIPerformance" name="test_chat_response_time" time="0.319"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_api.py, line 372&#10;      @pytest.mark.asyncio&#10;      async def test_chat_response_time(self, performance_monitor):&#10;          &quot;&quot;&quot;测试聊天响应时间&quot;&quot;&quot;&#10;          performance_monitor.start()&#10;&#10;          # 模拟聊天处理&#10;          mock_service = Mock()&#10;          mock_service.process_message = AsyncMock(return_value={&#10;              &quot;response&quot;: &quot;测试回复&quot;,&#10;              &quot;processing_time&quot;: 0.3&#10;          })&#10;&#10;          await mock_service.process_message(&quot;测试消息&quot;)&#10;&#10;          metrics = performance_monitor.stop()&#10;&#10;          # API响应时间应该在合理范围内&#10;          assert metrics[&quot;duration&quot;] &lt; 1.0&#10;E       fixture 'performance_monitor' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/api/test_chat_api.py::&lt;event_loop&gt;, unit/api/test_chat_api.py::TestAPIPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_api.py:372&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_api.py, line 372
      @pytest.mark.asyncio
      async def test_chat_response_time(self, performance_monitor):
          """测试聊天响应时间"""
          performance_monitor.start()

          # 模拟聊天处理
          mock_service = Mock()
          mock_service.process_message = AsyncMock(return_value={
              "response": "测试回复",
              "processing_time": 0.3
          })

          await mock_service.process_message("测试消息")

          metrics = performance_monitor.stop()

          # API响应时间应该在合理范围内
          assert metrics["duration"] &lt; 1.0
E       fixture 'performance_monitor' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/api/test_chat_api.py::&lt;event_loop&gt;, unit/api/test_chat_api.py::TestAPIPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_api.py:372</error></testcase><testcase classname="unit.api.test_chat_api.TestAPIPerformance" name="test_memory_usage_under_load" time="0.378"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_api.py, line 414&#10;      def test_memory_usage_under_load(self, performance_monitor):&#10;E       fixture 'performance_monitor' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/api/test_chat_api.py::&lt;event_loop&gt;, unit/api/test_chat_api.py::TestAPIPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_api.py:414&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_api.py, line 414
      def test_memory_usage_under_load(self, performance_monitor):
E       fixture 'performance_monitor' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/api/test_chat_api.py::&lt;event_loop&gt;, unit/api/test_chat_api.py::TestAPIPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_api.py:414</error></testcase><testcase classname="unit.api.test_chat_api.TestChatAPIIntegration" name="test_chat_with_context" time="0.395"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_chat_with_context&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_api.TestChatAPIIntegration" name="test_chat_with_emotion" time="0.334"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_chat_with_emotion&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_api.TestChatAPIIntegration" name="test_chat_endpoint_basic" time="0.333"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_chat_endpoint_basic&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_api.TestChatAPI" name="test_message_creation" time="0.334" /><testcase classname="unit.api.test_chat_api.TestChatAPI" name="test_message_validation" time="0.371" /><testcase classname="unit.api.test_chat_api.TestChatAPI" name="test_emotion_types" time="0.510" /><testcase classname="unit.api.test_chat_api.TestChatAPI" name="test_personality_types" time="0.427" /><testcase classname="unit.api.test_chat_api.TestChatAPI" name="test_character_config_validation" time="0.384" /><testcase classname="unit.api.test_chat_api.TestChatAPI" name="test_character_config_creation" time="0.400" /><testcase classname="unit.api.test_chat_api.TestAPIErrorHandling" name="test_invalid_message_content" time="0.381" /><testcase classname="unit.api.test_chat_api.TestAPIErrorHandling" name="test_service_unavailable_error" time="0.387"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_service_unavailable_error&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_api.TestAPIErrorHandling" name="test_personality_traits_limit" time="0.388" /><testcase classname="unit.api.test_chat_api.TestAPIErrorHandling" name="test_invalid_character_config" time="0.397" /><testcase classname="unit.api.test_chat_api.TestAPIErrorHandling" name="test_invalid_emotion_intensity" time="0.425" /><testcase classname="unit.api.test_chat_api.TestEmotionSystem" name="test_emotion_analysis" time="0.449"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_emotion_analysis&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_api.TestEmotionSystem" name="test_emotion_setting" time="0.389"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_emotion_setting&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_api.TestEmotionSystem" name="test_emotion_transitions" time="0.396" /><testcase classname="unit.api.test_chat_api.TestCharacterManagement" name="test_create_character" time="0.522"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_create_character&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_api.TestCharacterManagement" name="test_update_character" time="0.336"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_update_character&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_api.TestCharacterManagement" name="test_list_characters" time="0.485" /><testcase classname="unit.models.test_character_models.TestResponseModels" name="test_system_stats_response" time="0.390" /><testcase classname="unit.models.test_character_models.TestResponseModels" name="test_batch_operation_response" time="0.393" /><testcase classname="unit.models.test_character_models.TestResponseModels" name="test_emotion_response" time="0.328" /><testcase classname="unit.models.test_character_models.TestResponseModels" name="test_character_response" time="0.330" /><testcase classname="unit.models.test_character_models.TestResponseModels" name="test_emotion_analysis_response" time="0.391"><failure message="AttributeError: CHEERFUL">self = &lt;test_character_models.TestResponseModels object at 0x7fa35de543d0&gt;

    def test_emotion_analysis_response(self):
        """测试情绪分析响应"""
        detected_emotions = [
            {"emotion": "happy", "confidence": 0.9},
            {"emotion": "excited", "confidence": 0.7}
        ]
    
        response = EmotionAnalysisResponse(
            success=True,
            detected_emotions=detected_emotions,
            primary_emotion=EmotionType.HAPPY,
            confidence=0.9,
            emotion_keywords=["happy", "joy", "excited"],
&gt;           suggested_response_emotion=EmotionType.CHEERFUL,
            analysis_details={"method": "transformer", "model": "emotion-bert"}
        )

tests/unit/models/test_character_models.py:596: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;enum 'EmotionType'&gt;, name = 'CHEERFUL'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
&gt;           raise AttributeError(name) from None
E           AttributeError: CHEERFUL

/root/miniconda3/lib/python3.8/enum.py:384: AttributeError</failure></testcase><testcase classname="unit.models.test_character_models.TestResponseModels" name="test_character_list_response" time="0.385" /><testcase classname="unit.models.test_character_models.TestResponseModels" name="test_character_interaction_response" time="0.388"><failure message="AttributeError: CHEERFUL">self = &lt;test_character_models.TestResponseModels object at 0x7fa35df175b0&gt;

    def test_character_interaction_response(self):
        """测试角色交互响应"""
        response = CharacterInteractionResponse(
            success=True,
            response="Hello! I'm doing great, thank you for asking!",
&gt;           emotion=EmotionType.CHEERFUL,
            voice_style=VoiceStyle.SWEET,
            animation=AnimationType.HAPPY,
            processing_time=0.5,
            tokens_used=25,
            adapters_used=["openai-adapter"],
            learned_info={"user_preference": "polite_conversation"},
            personality_update={"cheerfulness": 0.1}
        )

tests/unit/models/test_character_models.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;enum 'EmotionType'&gt;, name = 'CHEERFUL'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
&gt;           raise AttributeError(name) from None
E           AttributeError: CHEERFUL

/root/miniconda3/lib/python3.8/enum.py:384: AttributeError</failure></testcase><testcase classname="unit.models.test_character_models.TestRequestModels" name="test_emotion_analysis_request" time="0.382" /><testcase classname="unit.models.test_character_models.TestRequestModels" name="test_character_interaction_request" time="0.425"><failure message="AttributeError: CHEERFUL">self = &lt;test_character_models.TestRequestModels object at 0x7fa35ddfb4c0&gt;

    def test_character_interaction_request(self):
        """测试角色交互请求"""
        request = CharacterInteractionRequest(
            character_id="char-123",
            message="How are you today?",
            context={"session_id": "session-456"},
&gt;           preferred_emotion=EmotionType.CHEERFUL,
            adapter_preferences=["openai-adapter", "claude-adapter"]
        )

tests/unit/models/test_character_models.py:500: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;enum 'EmotionType'&gt;, name = 'CHEERFUL'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
&gt;           raise AttributeError(name) from None
E           AttributeError: CHEERFUL

/root/miniconda3/lib/python3.8/enum.py:384: AttributeError</failure></testcase><testcase classname="unit.models.test_character_models.TestRequestModels" name="test_set_emotion_request" time="0.479" /><testcase classname="unit.models.test_character_models.TestRequestModels" name="test_create_character_request" time="0.419" /><testcase classname="unit.models.test_character_models.TestRequestModels" name="test_batch_character_operation" time="1.107" /><testcase classname="unit.models.test_character_models.TestRequestModels" name="test_update_character_request" time="0.332" /><testcase classname="unit.models.test_character_models.TestCharacterConfig" name="test_level_parameters_validation" time="0.382" /><testcase classname="unit.models.test_character_models.TestCharacterConfig" name="test_personality_traits_validation" time="0.380" /><testcase classname="unit.models.test_character_models.TestCharacterConfig" name="test_character_config_validation" time="0.390" /><testcase classname="unit.models.test_character_models.TestCharacterConfig" name="test_character_config_with_full_options" time="0.331" /><testcase classname="unit.models.test_character_models.TestCharacterConfig" name="test_emotion_history_validation" time="0.390" /><testcase classname="unit.models.test_character_models.TestCharacterConfig" name="test_max_response_length_validation" time="0.385" /><testcase classname="unit.models.test_character_models.TestCharacterConfig" name="test_character_config_creation_basic" time="0.400" /><testcase classname="unit.models.test_character_models.TestModelIntegration" name="test_character_config_to_dict_serialization" time="0.385" /><testcase classname="unit.models.test_character_models.TestModelIntegration" name="test_character_config_from_dict_deserialization" time="0.405" /><testcase classname="unit.models.test_character_models.TestModelIntegration" name="test_nested_model_validation" time="0.510" /><testcase classname="unit.models.test_character_models.TestModelIntegration" name="test_model_field_defaults" time="0.404" /><testcase classname="unit.models.test_character_models.TestCharacterState" name="test_character_state_with_context" time="0.397" /><testcase classname="unit.models.test_character_models.TestCharacterState" name="test_character_state_creation" time="0.380" /><testcase classname="unit.models.test_character_models.TestMessage" name="test_emotion_intensity_validation" time="0.404" /><testcase classname="unit.models.test_character_models.TestMessage" name="test_message_with_emotion" time="0.397" /><testcase classname="unit.models.test_character_models.TestMessage" name="test_message_creation_basic" time="0.401" /><testcase classname="unit.models.test_character_models.TestMessage" name="test_message_with_metadata" time="0.393" /><testcase classname="unit.models.test_character_models.TestMessage" name="test_message_length_limits" time="0.339" /><testcase classname="unit.models.test_character_models.TestMessage" name="test_message_content_validation" time="0.463" /><testcase classname="unit.models.test_character_models.TestMessage" name="test_message_with_multimedia" time="0.396" /><testcase classname="unit.models.test_character_models.TestEnumTypes" name="test_emotion_type_enum" time="0.388" /><testcase classname="unit.models.test_character_models.TestEnumTypes" name="test_animation_type_enum" time="0.399" /><testcase classname="unit.models.test_character_models.TestEnumTypes" name="test_personality_type_enum" time="0.598" /><testcase classname="unit.models.test_character_models.TestEnumTypes" name="test_message_role_enum" time="0.337" /><testcase classname="unit.models.test_character_models.TestEnumTypes" name="test_message_type_enum" time="0.393" /><testcase classname="unit.models.test_character_models.TestEnumTypes" name="test_voice_style_enum" time="0.383" /><testcase classname="unit.adapters.test_adapter_manager.TestAdapterIntegration" name="test_adapter_inference_pipeline" time="0.402"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 192&#10;      @pytest.mark.asyncio&#10;      async def test_adapter_inference_pipeline(self, adapter_manager, mock_model, mock_tokenizer):&#10;          &quot;&quot;&quot;测试适配器推理流程&quot;&quot;&quot;&#10;          # 模拟完整的推理流程&#10;          input_text = &quot;测试输入&quot;&#10;          expected_output = &quot;测试输出&quot;&#10;&#10;          # 设置mock行为&#10;          mock_tokenizer.encode.return_value = [1, 2, 3]&#10;          mock_model.generate.return_value = torch.tensor([[4, 5, 6]])&#10;          mock_tokenizer.decode.return_value = expected_output&#10;&#10;          # 模拟推理流程&#10;          adapter_manager.generate_with_adapter = AsyncMock(return_value=expected_output)&#10;&#10;          result = await adapter_manager.generate_with_adapter(&#10;              adapter_name=&quot;test_adapter&quot;,&#10;              input_text=input_text&#10;          )&#10;&#10;          assert result == expected_output&#10;E       fixture 'adapter_manager' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:192&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 192
      @pytest.mark.asyncio
      async def test_adapter_inference_pipeline(self, adapter_manager, mock_model, mock_tokenizer):
          """测试适配器推理流程"""
          # 模拟完整的推理流程
          input_text = "测试输入"
          expected_output = "测试输出"

          # 设置mock行为
          mock_tokenizer.encode.return_value = [1, 2, 3]
          mock_model.generate.return_value = torch.tensor([[4, 5, 6]])
          mock_tokenizer.decode.return_value = expected_output

          # 模拟推理流程
          adapter_manager.generate_with_adapter = AsyncMock(return_value=expected_output)

          result = await adapter_manager.generate_with_adapter(
              adapter_name="test_adapter",
              input_text=input_text
          )

          assert result == expected_output
E       fixture 'adapter_manager' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:192</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterIntegration" name="test_adapter_model_integration" time="0.383"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 182&#10;      @pytest.mark.asyncio&#10;      async def test_adapter_model_integration(self, adapter_manager, mock_model):&#10;          &quot;&quot;&quot;测试适配器与模型集成&quot;&quot;&quot;&#10;          # 模拟适配器加载到模型&#10;          adapter_manager.integrate_with_model = AsyncMock(return_value=True)&#10;&#10;          result = await adapter_manager.integrate_with_model(mock_model, &quot;test_adapter&quot;)&#10;&#10;          assert result is True&#10;E       fixture 'adapter_manager' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:182&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 182
      @pytest.mark.asyncio
      async def test_adapter_model_integration(self, adapter_manager, mock_model):
          """测试适配器与模型集成"""
          # 模拟适配器加载到模型
          adapter_manager.integrate_with_model = AsyncMock(return_value=True)

          result = await adapter_manager.integrate_with_model(mock_model, "test_adapter")

          assert result is True
E       fixture 'adapter_manager' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterIntegration::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:182</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_validate_adapter_config" time="0.393"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 114&#10;      def test_validate_adapter_config(self, adapter_manager, sample_adapter_config):&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 114
      def test_validate_adapter_config(self, adapter_manager, sample_adapter_config):
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_get_adapter_info" time="0.329"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 84&#10;      def test_get_adapter_info(self, adapter_manager):&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 84
      def test_get_adapter_info(self, adapter_manager):
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_load_adapter_success" time="0.397"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 39&#10;      @pytest.mark.asyncio&#10;      async def test_load_adapter_success(self, adapter_manager, sample_lora_weights):&#10;          &quot;&quot;&quot;测试成功加载适配器&quot;&quot;&quot;&#10;          adapter_manager.load_adapter = AsyncMock(return_value=True)&#10;&#10;          result = await adapter_manager.load_adapter(&#10;              adapter_name=&quot;test_adapter&quot;,&#10;              adapter_path=str(sample_lora_weights)&#10;          )&#10;&#10;          assert result is True&#10;          adapter_manager.load_adapter.assert_called_once()&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 39
      @pytest.mark.asyncio
      async def test_load_adapter_success(self, adapter_manager, sample_lora_weights):
          """测试成功加载适配器"""
          adapter_manager.load_adapter = AsyncMock(return_value=True)

          result = await adapter_manager.load_adapter(
              adapter_name="test_adapter",
              adapter_path=str(sample_lora_weights)
          )

          assert result is True
          adapter_manager.load_adapter.assert_called_once()
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_adapter_manager_initialization" time="0.405"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 32&#10;      def test_adapter_manager_initialization(self, adapter_manager):&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 32
      def test_adapter_manager_initialization(self, adapter_manager):
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_unload_adapter" time="0.375"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 63&#10;      @pytest.mark.asyncio&#10;      async def test_unload_adapter(self, adapter_manager):&#10;          &quot;&quot;&quot;测试卸载适配器&quot;&quot;&quot;&#10;          adapter_manager.unload_adapter = AsyncMock(return_value=True)&#10;          adapter_manager.loaded_adapters = {&quot;test_adapter&quot;: Mock()}&#10;&#10;          result = await adapter_manager.unload_adapter(&quot;test_adapter&quot;)&#10;&#10;          assert result is True&#10;          adapter_manager.unload_adapter.assert_called_once_with(&quot;test_adapter&quot;)&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 63
      @pytest.mark.asyncio
      async def test_unload_adapter(self, adapter_manager):
          """测试卸载适配器"""
          adapter_manager.unload_adapter = AsyncMock(return_value=True)
          adapter_manager.loaded_adapters = {"test_adapter": Mock()}

          result = await adapter_manager.unload_adapter("test_adapter")

          assert result is True
          adapter_manager.unload_adapter.assert_called_once_with("test_adapter")
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_batch_load_adapters" time="0.406"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 123&#10;      @pytest.mark.asyncio&#10;      async def test_batch_load_adapters(self, adapter_manager):&#10;          &quot;&quot;&quot;测试批量加载适配器&quot;&quot;&quot;&#10;          adapter_list = [&quot;adapter1&quot;, &quot;adapter2&quot;, &quot;adapter3&quot;]&#10;          adapter_manager.batch_load = AsyncMock(return_value={&quot;success&quot;: 2, &quot;failed&quot;: 1})&#10;&#10;          result = await adapter_manager.batch_load(adapter_list)&#10;&#10;          assert result[&quot;success&quot;] == 2&#10;          assert result[&quot;failed&quot;] == 1&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 123
      @pytest.mark.asyncio
      async def test_batch_load_adapters(self, adapter_manager):
          """测试批量加载适配器"""
          adapter_list = ["adapter1", "adapter2", "adapter3"]
          adapter_manager.batch_load = AsyncMock(return_value={"success": 2, "failed": 1})

          result = await adapter_manager.batch_load(adapter_list)

          assert result["success"] == 2
          assert result["failed"] == 1
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_memory_usage_tracking" time="0.393"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 134&#10;      def test_memory_usage_tracking(self, adapter_manager):&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 134
      def test_memory_usage_tracking(self, adapter_manager):
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_switch_adapter" time="0.391"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 101&#10;      @pytest.mark.asyncio&#10;      async def test_switch_adapter(self, adapter_manager):&#10;          &quot;&quot;&quot;测试切换适配器&quot;&quot;&quot;&#10;          adapter_manager.switch_adapter = AsyncMock(return_value=True)&#10;&#10;          result = await adapter_manager.switch_adapter(&#10;              from_adapter=&quot;adapter1&quot;,&#10;              to_adapter=&quot;adapter2&quot;&#10;          )&#10;&#10;          assert result is True&#10;          adapter_manager.switch_adapter.assert_called_once()&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 101
      @pytest.mark.asyncio
      async def test_switch_adapter(self, adapter_manager):
          """测试切换适配器"""
          adapter_manager.switch_adapter = AsyncMock(return_value=True)

          result = await adapter_manager.switch_adapter(
              from_adapter="adapter1",
              to_adapter="adapter2"
          )

          assert result is True
          adapter_manager.switch_adapter.assert_called_once()
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_list_adapters" time="0.513"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 74&#10;      def test_list_adapters(self, adapter_manager):&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 74
      def test_list_adapters(self, adapter_manager):
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterManager" name="test_load_adapter_failure" time="0.390"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 52&#10;      @pytest.mark.asyncio&#10;      async def test_load_adapter_failure(self, adapter_manager):&#10;          &quot;&quot;&quot;测试加载适配器失败&quot;&quot;&quot;&#10;          adapter_manager.load_adapter = AsyncMock(side_effect=FileNotFoundError(&quot;适配器文件不存在&quot;))&#10;&#10;          with pytest.raises(FileNotFoundError):&#10;              await adapter_manager.load_adapter(&#10;                  adapter_name=&quot;nonexistent_adapter&quot;,&#10;                  adapter_path=&quot;/nonexistent/path&quot;&#10;              )&#10;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21&#10;      @pytest.fixture&#10;      def adapter_manager(self, mock_model, mock_tokenizer):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 52
      @pytest.mark.asyncio
      async def test_load_adapter_failure(self, adapter_manager):
          """测试加载适配器失败"""
          adapter_manager.load_adapter = AsyncMock(side_effect=FileNotFoundError("适配器文件不存在"))

          with pytest.raises(FileNotFoundError):
              await adapter_manager.load_adapter(
                  adapter_name="nonexistent_adapter",
                  adapter_path="/nonexistent/path"
              )
file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 21
      @pytest.fixture
      def adapter_manager(self, mock_model, mock_tokenizer):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, adapter_manager, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterManager::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:21</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterCompatibility" name="test_adapter_version_compatibility" time="0.384" /><testcase classname="unit.adapters.test_adapter_manager.TestAdapterCompatibility" name="test_model_adapter_compatibility" time="0.413"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 170&#10;      def test_model_adapter_compatibility(self, mock_model):&#10;E       fixture 'mock_model' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterCompatibility::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:170&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 170
      def test_model_adapter_compatibility(self, mock_model):
E       fixture 'mock_model' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterCompatibility::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:170</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterCompatibility" name="test_lora_adapter_compatibility" time="0.386"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 155&#10;      def test_lora_adapter_compatibility(self, sample_adapter_config):&#10;E       fixture 'sample_adapter_config' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterCompatibility::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:155&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 155
      def test_lora_adapter_compatibility(self, sample_adapter_config):
E       fixture 'sample_adapter_config' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterCompatibility::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:155</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterPerformance" name="test_concurrent_adapter_operations" time="0.389"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 248&#10;      def test_concurrent_adapter_operations(self, adapter_manager):&#10;E       fixture 'adapter_manager' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:248&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 248
      def test_concurrent_adapter_operations(self, adapter_manager):
E       fixture 'adapter_manager' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:248</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterPerformance" name="test_adapter_loading_speed" time="0.383"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 219&#10;      @pytest.mark.asyncio&#10;      async def test_adapter_loading_speed(self, adapter_manager, performance_monitor):&#10;          &quot;&quot;&quot;测试适配器加载速度&quot;&quot;&quot;&#10;          performance_monitor.start()&#10;&#10;          # 模拟适配器加载&#10;          adapter_manager.load_adapter = AsyncMock(return_value=True)&#10;          await adapter_manager.load_adapter(&quot;test_adapter&quot;, &quot;/test/path&quot;)&#10;&#10;          metrics = performance_monitor.stop()&#10;&#10;          # 断言加载时间在合理范围内（例如小于5秒）&#10;          assert metrics[&quot;duration&quot;] &lt; 5.0&#10;E       fixture 'adapter_manager' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:219&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 219
      @pytest.mark.asyncio
      async def test_adapter_loading_speed(self, adapter_manager, performance_monitor):
          """测试适配器加载速度"""
          performance_monitor.start()

          # 模拟适配器加载
          adapter_manager.load_adapter = AsyncMock(return_value=True)
          await adapter_manager.load_adapter("test_adapter", "/test/path")

          metrics = performance_monitor.stop()

          # 断言加载时间在合理范围内（例如小于5秒）
          assert metrics["duration"] &lt; 5.0
E       fixture 'adapter_manager' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:219</error></testcase><testcase classname="unit.adapters.test_adapter_manager.TestAdapterPerformance" name="test_adapter_memory_efficiency" time="0.403"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 233&#10;      @pytest.mark.asyncio&#10;      async def test_adapter_memory_efficiency(self, adapter_manager, performance_monitor):&#10;          &quot;&quot;&quot;测试适配器内存效率&quot;&quot;&quot;&#10;          performance_monitor.start()&#10;&#10;          # 模拟多个适配器加载&#10;          for i in range(3):&#10;              adapter_manager.load_adapter = AsyncMock(return_value=True)&#10;              await adapter_manager.load_adapter(f&quot;adapter_{i}&quot;, f&quot;/test/path_{i}&quot;)&#10;&#10;          metrics = performance_monitor.stop()&#10;&#10;          # 断言内存使用在合理范围内（例如小于1GB）&#10;          assert metrics[&quot;memory_used&quot;] &lt; 1024 * 1024 * 1024  # 1GB&#10;E       fixture 'adapter_manager' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:233&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py, line 233
      @pytest.mark.asyncio
      async def test_adapter_memory_efficiency(self, adapter_manager, performance_monitor):
          """测试适配器内存效率"""
          performance_monitor.start()

          # 模拟多个适配器加载
          for i in range(3):
              adapter_manager.load_adapter = AsyncMock(return_value=True)
              await adapter_manager.load_adapter(f"adapter_{i}", f"/test/path_{i}")

          metrics = performance_monitor.stop()

          # 断言内存使用在合理范围内（例如小于1GB）
          assert metrics["memory_used"] &lt; 1024 * 1024 * 1024  # 1GB
E       fixture 'adapter_manager' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_adapter_manager.py::&lt;event_loop&gt;, unit/adapters/test_adapter_manager.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_adapter_manager.py:233</error></testcase><testcase classname="unit.api.test_health_routes.TestAdapterChecker" name="test_adapter_check_with_status" time="0.394"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_adapter_check_with_status&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestAdapterChecker" name="test_adapter_check_failure" time="0.397"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_adapter_check_failure&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestAdapterChecker" name="test_adapter_check_without_status" time="0.399"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_adapter_check_without_status&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestHealthStatus" name="test_health_status_comparison" time="0.384" /><testcase classname="unit.api.test_health_routes.TestHealthStatus" name="test_health_status_values" time="0.497" /><testcase classname="unit.api.test_health_routes.TestHealthUtilities" name="test_get_health_status_with_exceptions" time="0.392"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_get_health_status_with_exceptions&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestHealthUtilities" name="test_get_health_status_with_failures" time="0.335"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_get_health_status_with_failures&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestHealthUtilities" name="test_get_uptime" time="0.392" /><testcase classname="unit.api.test_health_routes.TestHealthUtilities" name="test_get_health_status_all_healthy" time="0.419"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_get_health_status_all_healthy&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestHealthRoutes" name="test_health_check_endpoint" time="0.413"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_health_routes.py:488: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_health_routes.TestHealthRoutes" name="test_ping_endpoint" time="0.497"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_health_routes.py:492: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_health_routes.TestHealthRoutes" name="test_deep_health_check_endpoint" time="0.400"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_health_routes.py:496: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_health_routes.TestModelChecker" name="test_model_check_without_gpu" time="0.346"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_model_check_without_gpu&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestModelChecker" name="test_model_check_with_gpu" time="1.793"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_model_check_with_gpu&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestHealthChecker" name="test_timeout_check" time="1.206"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_timeout_check&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestHealthChecker" name="test_failed_check" time="0.397"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_failed_check&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestHealthChecker" name="test_successful_check" time="0.327"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_successful_check&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestHealthPerformance" name="test_parallel_health_checks" time="0.566"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_parallel_health_checks&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestHealthPerformance" name="test_health_check_performance" time="0.610"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_health_check_performance&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestDeepHealthResponse" name="test_deep_health_response_creation" time="0.381" /><testcase classname="unit.api.test_health_routes.TestCheckResult" name="test_check_result_creation" time="0.418" /><testcase classname="unit.api.test_health_routes.TestCheckResult" name="test_check_result_with_details" time="0.393" /><testcase classname="unit.api.test_health_routes.TestSystemChecker" name="test_system_check_degraded" time="0.385"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_system_check_degraded&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestSystemChecker" name="test_system_check_healthy" time="0.322"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_system_check_healthy&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_health_routes.TestSystemChecker" name="test_system_check_failure" time="0.437"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_system_check_failure&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.adapters.test_base_adapter.TestBaseAdapter" name="test_adapter_load_state_dict" time="0.403" /><testcase classname="unit.adapters.test_base_adapter.TestBaseAdapter" name="test_adapter_parameter_update" time="0.464" /><testcase classname="unit.adapters.test_base_adapter.TestBaseAdapter" name="test_adapter_unload" time="0.605"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_adapter_unload&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.adapters.test_base_adapter.TestBaseAdapter" name="test_adapter_initialization" time="0.488" /><testcase classname="unit.adapters.test_base_adapter.TestBaseAdapter" name="test_adapter_get_info" time="0.597" /><testcase classname="unit.adapters.test_base_adapter.TestBaseAdapter" name="test_adapter_config_validation" time="0.325" /><testcase classname="unit.adapters.test_base_adapter.TestBaseAdapter" name="test_adapter_load" time="0.392"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_adapter_load&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.adapters.test_base_adapter.TestBaseAdapter" name="test_adapter_device_management" time="0.413" /><testcase classname="unit.adapters.test_base_adapter.TestBaseAdapter" name="test_adapter_state_dict" time="0.391" /><testcase classname="unit.adapters.test_base_adapter.TestAdapterPerformance" name="test_adapter_concurrent_access" time="0.381"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 337&#10;      def test_adapter_concurrent_access(self, mock_base_adapter):&#10;E       fixture 'mock_base_adapter' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:337&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 337
      def test_adapter_concurrent_access(self, mock_base_adapter):
E       fixture 'mock_base_adapter' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:337</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterPerformance" name="test_adapter_initialization_speed" time="0.394"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 321&#10;      def test_adapter_initialization_speed(self, performance_monitor):&#10;E       fixture 'performance_monitor' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:321&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 321
      def test_adapter_initialization_speed(self, performance_monitor):
E       fixture 'performance_monitor' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:321</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterPerformance" name="test_adapter_memory_footprint" time="0.490"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 304&#10;      def test_adapter_memory_footprint(self, mock_base_adapter, performance_monitor):&#10;E       fixture 'mock_base_adapter' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:304&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 304
      def test_adapter_memory_footprint(self, mock_base_adapter, performance_monitor):
E       fixture 'mock_base_adapter' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterPerformance::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:304</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterExceptions" name="test_adapter_device_error" time="0.329"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 398&#10;      def test_adapter_device_error(self, mock_base_adapter):&#10;E       fixture 'mock_base_adapter' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterExceptions::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:398&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 398
      def test_adapter_device_error(self, mock_base_adapter):
E       fixture 'mock_base_adapter' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterExceptions::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:398</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterExceptions" name="test_adapter_parameter_error" time="0.320"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 405&#10;      def test_adapter_parameter_error(self, mock_base_adapter):&#10;E       fixture 'mock_base_adapter' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterExceptions::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:405&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 405
      def test_adapter_parameter_error(self, mock_base_adapter):
E       fixture 'mock_base_adapter' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterExceptions::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:405</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterExceptions" name="test_adapter_config_error" time="0.385" /><testcase classname="unit.adapters.test_base_adapter.TestAdapterExceptions" name="test_adapter_load_failure" time="0.708"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 375&#10;      def test_adapter_load_failure(self, mock_base_adapter):&#10;E       fixture 'mock_base_adapter' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterExceptions::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:375&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 375
      def test_adapter_load_failure(self, mock_base_adapter):
E       fixture 'mock_base_adapter' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterExceptions::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:375</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterConfig" name="test_config_validation_rules" time="0.337" /><testcase classname="unit.adapters.test_base_adapter.TestAdapterConfig" name="test_config_creation" time="2.082"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 178&#10;      def test_config_creation(self, base_adapter_config):&#10;E       fixture 'base_adapter_config' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterConfig::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:178&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 178
      def test_config_creation(self, base_adapter_config):
E       fixture 'base_adapter_config' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterConfig::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:178</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterConfig" name="test_config_parameter_types" time="0.587"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 220&#10;      def test_config_parameter_types(self, base_adapter_config):&#10;E       fixture 'base_adapter_config' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterConfig::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:220&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 220
      def test_config_parameter_types(self, base_adapter_config):
E       fixture 'base_adapter_config' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterConfig::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:220</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterConfig" name="test_config_serialization" time="0.384"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 195&#10;      def test_config_serialization(self, base_adapter_config):&#10;E       fixture 'base_adapter_config' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterConfig::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:195&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 195
      def test_config_serialization(self, base_adapter_config):
E       fixture 'base_adapter_config' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterConfig::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:195</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterFileOperations" name="test_adapter_directory_structure" time="0.337" /><testcase classname="unit.adapters.test_base_adapter.TestAdapterFileOperations" name="test_adapter_save_load" time="0.382"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 245&#10;      def test_adapter_save_load(self, temp_adapter_dir, base_adapter_config):&#10;E       fixture 'base_adapter_config' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_adapter_dir, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterFileOperations::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:245&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 245
      def test_adapter_save_load(self, temp_adapter_dir, base_adapter_config):
E       fixture 'base_adapter_config' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_adapter_dir, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterFileOperations::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:245</error></testcase><testcase classname="unit.adapters.test_base_adapter.TestAdapterFileOperations" name="test_adapter_backup_restore" time="0.386"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 277&#10;      def test_adapter_backup_restore(self, temp_adapter_dir, base_adapter_config):&#10;E       fixture 'base_adapter_config' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_adapter_dir, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterFileOperations::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:277&quot;">file /root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py, line 277
      def test_adapter_backup_restore(self, temp_adapter_dir, base_adapter_config):
E       fixture 'base_adapter_config' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_adapter_dir, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unit/adapters/test_base_adapter.py::&lt;event_loop&gt;, unit/adapters/test_base_adapter.py::TestAdapterFileOperations::&lt;event_loop&gt;, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/unit/adapters/test_base_adapter.py:277</error></testcase><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_request_with_functions" time="0.471"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for ChatCompletionRequest&#10;messages.0&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='ce3f2a78-cfd6...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type">self = &lt;test_schemas.TestChatSchemas object at 0x7fa35df17280&gt;

    def test_chat_request_with_functions(self):
        """测试带函数的聊天请求"""
        messages = [
            Message(
                role=MessageRole.USER,
                content="What's the weather like?",
                timestamp=datetime.now(timezone.utc)
            )
        ]
    
        functions = [
            {
                "name": "get_weather",
                "description": "Get weather information",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "location": {"type": "string"}
                    }
                }
            }
        ]
    
&gt;       request = ChatCompletionRequest(
            messages=messages,
            model="gpt-3.5-turbo",
            functions=functions,
            function_call="auto"
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for ChatCompletionRequest
E       messages.0
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='ce3f2a78-cfd6...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type

tests/unit/api/test_schemas.py:170: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_message_function_call" time="0.494" /><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_message_with_metadata" time="0.427" /><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_message_invalid_role" time="0.402" /><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_request_valid" time="0.419"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for ChatCompletionRequest&#10;messages.0&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='599d1f2b-af6c...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type">self = &lt;test_schemas.TestChatSchemas object at 0x7fa35df06fd0&gt;

    def test_chat_request_valid(self):
        """测试有效的聊天请求"""
        messages = [
            Message(
                role=MessageRole.USER,
                content="Hello",
                timestamp=datetime.now(timezone.utc)
            )
        ]
    
&gt;       request = ChatCompletionRequest(
            messages=messages,
            model="gpt-3.5-turbo",
            temperature=0.7,
            max_tokens=1000,
            stream=False
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for ChatCompletionRequest
E       messages.0
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='599d1f2b-af6c...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type

tests/unit/api/test_schemas.py:133: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_history_valid" time="0.517"><failure message="pydantic_core._pydantic_core.ValidationError: 3 validation errors for ChatHistory&#10;session_id&#10;  Field required [type=missing, input_value={'conversation_id': '08cf...e': 'Test Conversation'}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;total_messages&#10;  Field required [type=missing, input_value={'conversation_id': '08cf...e': 'Test Conversation'}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;created&#10;  Field required [type=missing, input_value={'conversation_id': '08cf...e': 'Test Conversation'}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing">self = &lt;test_schemas.TestChatSchemas object at 0x7fa35df17970&gt;

    def test_chat_history_valid(self):
        """测试有效的聊天历史"""
        messages = [
            Message(
                role=MessageRole.USER,
                content="Hello",
                timestamp=datetime.now(timezone.utc)
            ),
            Message(
                role=MessageRole.ASSISTANT,
                content="Hi there!",
                timestamp=datetime.now(timezone.utc)
            )
        ]
    
&gt;       history = ChatHistory(
            conversation_id=str(uuid.uuid4()),
            messages=messages,
            created_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc),
            title="Test Conversation"
        )
E       pydantic_core._pydantic_core.ValidationError: 3 validation errors for ChatHistory
E       session_id
E         Field required [type=missing, input_value={'conversation_id': '08cf...e': 'Test Conversation'}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       total_messages
E         Field required [type=missing, input_value={'conversation_id': '08cf...e': 'Test Conversation'}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       created
E         Field required [type=missing, input_value={'conversation_id': '08cf...e': 'Test Conversation'}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing

tests/unit/api/test_schemas.py:279: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_request_invalid_temperature" time="0.395" /><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_stream_response_valid" time="0.384" /><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_conversation_summary_valid" time="0.385"><failure message="pydantic_core._pydantic_core.ValidationError: 2 validation errors for ConversationSummary&#10;id&#10;  Field required [type=missing, input_value={'conversation_id': 'e2ea...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;created&#10;  Field required [type=missing, input_value={'conversation_id': 'e2ea...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing">self = &lt;test_schemas.TestChatSchemas object at 0x7fa35df17be0&gt;

    def test_conversation_summary_valid(self):
        """测试有效的对话摘要"""
&gt;       summary = ConversationSummary(
            conversation_id=str(uuid.uuid4()),
            title="Weather Discussion",
            summary="User asked about weather, assistant provided information",
            message_count=5,
            created_at=datetime.now(timezone.utc),
            last_message_at=datetime.now(timezone.utc)
        )
E       pydantic_core._pydantic_core.ValidationError: 2 validation errors for ConversationSummary
E       id
E         Field required [type=missing, input_value={'conversation_id': 'e2ea...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       created
E         Field required [type=missing, input_value={'conversation_id': 'e2ea...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing

tests/unit/api/test_schemas.py:293: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_stream_response_finished" time="0.400" /><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_message_valid" time="0.415" /><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_message_empty_content" time="0.709"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for Message&#10;  Value error, 消息内容不能为空 [type=value_error, input_value={'role': &lt;MessageRole.FUN...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/value_error">self = &lt;test_schemas.TestChatSchemas object at 0x7fa35df06d60&gt;

    def test_chat_message_empty_content(self):
        """测试空内容消息"""
        # 空内容应该被允许（特别是对于函数调用）
&gt;       message = Message(
            role=MessageRole.FUNCTION,
            content="",
            name="get_weather",
            timestamp=datetime.now(timezone.utc)
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Message
E         Value error, 消息内容不能为空 [type=value_error, input_value={'role': &lt;MessageRole.FUN...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/value_error

tests/unit/api/test_schemas.py:113: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_response_valid" time="0.397" /><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_chat_request_invalid_max_tokens" time="0.509" /><testcase classname="unit.api.test_schemas.TestChatSchemas" name="test_message_role_enum" time="0.396" /><testcase classname="unit.api.test_schemas.TestSchemaValidation" name="test_nested_model_validation" time="0.393"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for ChatCompletionRequest&#10;messages.0&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='c15cc4e6-2ac7...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type">self = &lt;test_schemas.TestSchemaValidation object at 0x7fa35deae700&gt;

    def test_nested_model_validation(self):
        """测试嵌套模型验证"""
        # 创建包含嵌套模型的复杂数据结构
        message = Message(
            role=MessageRole.USER,
            content="Test message",
            timestamp=datetime.now(timezone.utc)
        )
    
&gt;       request = ChatCompletionRequest(
            messages=[message],
            model="gpt-3.5-turbo",
            temperature=0.7
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for ChatCompletionRequest
E       messages.0
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='c15cc4e6-2ac7...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type

tests/unit/api/test_schemas.py:703: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestSchemaValidation" name="test_field_constraints_validation" time="0.401" /><testcase classname="unit.api.test_schemas.TestSchemaValidation" name="test_datetime_serialization" time="0.390" /><testcase classname="unit.api.test_schemas.TestSchemaValidation" name="test_model_copy_and_update" time="0.388" /><testcase classname="unit.api.test_schemas.TestSchemaValidation" name="test_optional_field_validation" time="0.385"><failure message="AssertionError: assert {} is None&#10; +  where {} = Message(id='dd38b51d-3784-4467-8ebf-a5a79f84f508', role=&lt;MessageRole.USER: 'user'&gt;, content='Test', message_type=&lt;Mess... emotion_intensity=None, voice_style=None, animation=None, avatar=None, metadata={}, tokens=None, processing_time=None).metadata">self = &lt;test_schemas.TestSchemaValidation object at 0x7fa35deae970&gt;

    def test_optional_field_validation(self):
        """测试可选字段验证"""
        # 只提供必需字段
        message = Message(
            role=MessageRole.USER,
            content="Test",
            timestamp=datetime.now(timezone.utc)
        )
    
        assert message.name is None
        assert message.function_call is None
&gt;       assert message.metadata is None
E       AssertionError: assert {} is None
E        +  where {} = Message(id='dd38b51d-3784-4467-8ebf-a5a79f84f508', role=&lt;MessageRole.USER: 'user'&gt;, content='Test', message_type=&lt;Mess... emotion_intensity=None, voice_style=None, animation=None, avatar=None, metadata={}, tokens=None, processing_time=None).metadata

tests/unit/api/test_schemas.py:725: AssertionError</failure></testcase><testcase classname="unit.api.test_schemas.TestSchemaValidation" name="test_custom_validator_methods" time="0.413" /><testcase classname="unit.api.test_schemas.TestCommonSchemas" name="test_base_response_valid" time="0.402"><failure message="NameError: name 'BaseResponse' is not defined">self = &lt;test_schemas.TestCommonSchemas object at 0x7fa35df27100&gt;

    def test_base_response_valid(self):
        """测试有效的基础响应"""
&gt;       response = BaseResponse(
            success=True,
            message="Operation completed successfully",
            timestamp=datetime.now(timezone.utc),
            request_id=str(uuid.uuid4())
        )
E       NameError: name 'BaseResponse' is not defined

tests/unit/api/test_schemas.py:592: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestCommonSchemas" name="test_error_response_valid" time="0.471"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for ErrorResponse&#10;error_type&#10;  Field required [type=missing, input_value={'success': False, 'messa...41ff-b0af-ef97cfb17712'}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing">self = &lt;test_schemas.TestCommonSchemas object at 0x7fa35df27370&gt;

    def test_error_response_valid(self):
        """测试有效的错误响应"""
&gt;       response = ErrorResponse(
            success=False,
            message="Validation failed",
            error_code="VALIDATION_ERROR",
            error_details={
                "field": "email",
                "reason": "Invalid format"
            },
            timestamp=datetime.now(timezone.utc),
            request_id=str(uuid.uuid4())
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for ErrorResponse
E       error_type
E         Field required [type=missing, input_value={'success': False, 'messa...41ff-b0af-ef97cfb17712'}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing

tests/unit/api/test_schemas.py:606: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestCommonSchemas" name="test_pagination_params_invalid_size" time="0.582"><failure message="NameError: name 'PaginationParams' is not defined">self = &lt;test_schemas.TestCommonSchemas object at 0x7fa35df27ac0&gt;

    def test_pagination_params_invalid_size(self):
        """测试无效的页面大小"""
        with pytest.raises(ValidationError):
&gt;           PaginationParams(
                page=1,
                size=0  # 页面大小应该大于0
            )
E           NameError: name 'PaginationParams' is not defined

tests/unit/api/test_schemas.py:647: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestCommonSchemas" name="test_sort_order_enum" time="0.408"><failure message="NameError: name 'SortOrder' is not defined">self = &lt;test_schemas.TestCommonSchemas object at 0x7fa35df27d30&gt;

    def test_sort_order_enum(self):
        """测试排序顺序枚举"""
&gt;       assert SortOrder.ASC == "asc"
E       NameError: name 'SortOrder' is not defined

tests/unit/api/test_schemas.py:654: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestCommonSchemas" name="test_pagination_params_valid" time="0.517"><failure message="NameError: name 'PaginationParams' is not defined">self = &lt;test_schemas.TestCommonSchemas object at 0x7fa35df275e0&gt;

    def test_pagination_params_valid(self):
        """测试有效的分页参数"""
&gt;       params = PaginationParams(
            page=2,
            size=20,
            sort_by="created_at",
            sort_order=SortOrder.DESC
        )
E       NameError: name 'PaginationParams' is not defined

tests/unit/api/test_schemas.py:624: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestCommonSchemas" name="test_api_version_valid" time="0.393"><failure message="NameError: name 'APIVersion' is not defined">self = &lt;test_schemas.TestCommonSchemas object at 0x7fa35deae280&gt;

    def test_api_version_valid(self):
        """测试有效的API版本"""
&gt;       version = APIVersion(
            version="v1.2.3",
            build="20241001.1",
            commit_hash="abc123def456",
            release_date=datetime(2024, 10, 1, tzinfo=timezone.utc)
        )
E       NameError: name 'APIVersion' is not defined

tests/unit/api/test_schemas.py:677: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestCommonSchemas" name="test_pagination_params_invalid_page" time="0.491"><failure message="NameError: name 'PaginationParams' is not defined">self = &lt;test_schemas.TestCommonSchemas object at 0x7fa35df27850&gt;

    def test_pagination_params_invalid_page(self):
        """测试无效的页码"""
        with pytest.raises(ValidationError):
&gt;           PaginationParams(
                page=0,  # 页码应该从1开始
                size=20
            )
E           NameError: name 'PaginationParams' is not defined

tests/unit/api/test_schemas.py:639: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestCommonSchemas" name="test_filter_params_valid" time="0.482"><failure message="NameError: name 'FilterParams' is not defined">self = &lt;test_schemas.TestCommonSchemas object at 0x7fa35df27fd0&gt;

    def test_filter_params_valid(self):
        """测试有效的过滤参数"""
&gt;       params = FilterParams(
            filters={
                "status": "active",
                "category": "test",
                "created_after": "2024-01-01"
            },
            search="test query",
            date_from=datetime(2024, 1, 1, tzinfo=timezone.utc),
            date_to=datetime(2024, 12, 31, tzinfo=timezone.utc)
        )
E       NameError: name 'FilterParams' is not defined

tests/unit/api/test_schemas.py:659: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_adapter_switch_request_same_adapter" time="0.577"><failure message="Failed: DID NOT RAISE &lt;class 'pydantic_core._pydantic_core.ValidationError'&gt;">self = &lt;test_schemas.TestModelSchemas object at 0x7fa35df211f0&gt;

    def test_adapter_switch_request_same_adapter(self):
        """测试切换到相同适配器"""
        with pytest.raises(ValidationError):
&gt;           AdapterSwitchRequest(
                from_adapter_id="adapter-1",
                to_adapter_id="adapter-1",  # 相同的适配器
                unload_previous=True
            )
E           Failed: DID NOT RAISE &lt;class 'pydantic_core._pydantic_core.ValidationError'&gt;

tests/unit/api/test_schemas.py:413: Failed</failure></testcase><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_adapter_info_size_formatting" time="0.495"><failure message="pydantic_core._pydantic_core.ValidationError: 3 validation errors for AdapterInfo&#10;metadata&#10;  Field required [type=missing, input_value={'name': 'test-adapter', ...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;config&#10;  Field required [type=missing, input_value={'name': 'test-adapter', ...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;load_time&#10;  Input should be a valid number [type=float_type, input_value=datetime.datetime(2025, 1...o=datetime.timezone.utc), input_type=datetime]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/float_type">self = &lt;test_schemas.TestModelSchemas object at 0x7fa35df1c310&gt;

    def test_adapter_info_size_formatting(self):
        """测试适配器大小格式化"""
&gt;       info = AdapterInfo(
            name="test-adapter",
            path="/path/to/adapter",
            size=1536*1024*1024,  # 1.5GB
            version="1.0.0",
            status="loaded",
            load_time=datetime.now(timezone.utc)
        )
E       pydantic_core._pydantic_core.ValidationError: 3 validation errors for AdapterInfo
E       metadata
E         Field required [type=missing, input_value={'name': 'test-adapter', ...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       config
E         Field required [type=missing, input_value={'name': 'test-adapter', ...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       load_time
E         Input should be a valid number [type=float_type, input_value=datetime.datetime(2025, 1...o=datetime.timezone.utc), input_type=datetime]
E           For further information visit https://errors.pydantic.dev/2.10/v/float_type

tests/unit/api/test_schemas.py:336: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_adapter_info_valid" time="0.475"><failure message="pydantic_core._pydantic_core.ValidationError: 3 validation errors for AdapterInfo&#10;metadata&#10;  Field required [type=missing, input_value={'name': 'test-adapter', ....001, 'batch_size': 32}}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;config.adapter_type&#10;  Field required [type=missing, input_value={'learning_rate': 0.001, 'batch_size': 32}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;load_time&#10;  Input should be a valid number [type=float_type, input_value=datetime.datetime(2025, 1...o=datetime.timezone.utc), input_type=datetime]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/float_type">self = &lt;test_schemas.TestModelSchemas object at 0x7fa35df1c0a0&gt;

    def test_adapter_info_valid(self):
        """测试有效的适配器信息"""
&gt;       info = AdapterInfo(
            name="test-adapter",
            path="/path/to/adapter",
            size=1024*1024*1024,  # 1GB
            version="1.0.0",
            description="Test adapter for unit testing",
            status="loaded",
            load_time=datetime.now(timezone.utc),
            memory_usage=512*1024*1024,  # 512MB
            config={
                "learning_rate": 0.001,
                "batch_size": 32
            }
        )
E       pydantic_core._pydantic_core.ValidationError: 3 validation errors for AdapterInfo
E       metadata
E         Field required [type=missing, input_value={'name': 'test-adapter', ....001, 'batch_size': 32}}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       config.adapter_type
E         Field required [type=missing, input_value={'learning_rate': 0.001, 'batch_size': 32}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       load_time
E         Input should be a valid number [type=float_type, input_value=datetime.datetime(2025, 1...o=datetime.timezone.utc), input_type=datetime]
E           For further information visit https://errors.pydantic.dev/2.10/v/float_type

tests/unit/api/test_schemas.py:314: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_model_status_valid" time="0.394"><failure message="pydantic_core._pydantic_core.ValidationError: 2 validation errors for ModelStatus&#10;name&#10;  Field required [type=missing, input_value={'status': 'healthy', 'lo...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;status&#10;  Input should be 'loaded', 'unloaded' or 'error' [type=literal_error, input_value='healthy', input_type=str]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/literal_error">self = &lt;test_schemas.TestModelSchemas object at 0x7fa35df21460&gt;

    def test_model_status_valid(self):
        """测试有效的模型状态"""
&gt;       status = ModelStatus(
            status="healthy",
            loaded_adapters=["adapter-1", "adapter-2"],
            total_memory_usage=2048*1024*1024,  # 2GB
            available_memory=6144*1024*1024,    # 6GB
            gpu_info={
                "cuda:0": {
                    "name": "Tesla V100",
                    "memory_used": 1024*1024*1024,
                    "memory_total": 16*1024*1024*1024
                }
            },
            last_updated=datetime.now(timezone.utc)
        )
E       pydantic_core._pydantic_core.ValidationError: 2 validation errors for ModelStatus
E       name
E         Field required [type=missing, input_value={'status': 'healthy', 'lo...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       status
E         Input should be 'loaded', 'unloaded' or 'error' [type=literal_error, input_value='healthy', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.10/v/literal_error

tests/unit/api/test_schemas.py:421: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_adapter_load_request_invalid_name" time="0.387" /><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_adapter_unload_request_valid" time="0.465"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for AdapterUnloadRequest&#10;adapter_id&#10;  Field required [type=missing, input_value={'adapter_name': 'test-ad... 'cleanup_memory': True}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing">self = &lt;test_schemas.TestModelSchemas object at 0x7fa35df1ccd0&gt;

    def test_adapter_unload_request_valid(self):
        """测试有效的适配器卸载请求"""
&gt;       request = AdapterUnloadRequest(
            adapter_name="test-adapter",
            force=False,
            cleanup_memory=True
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for AdapterUnloadRequest
E       adapter_id
E         Field required [type=missing, input_value={'adapter_name': 'test-ad... 'cleanup_memory': True}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing

tests/unit/api/test_schemas.py:384: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_adapter_load_request_invalid_path" time="0.335" /><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_adapter_switch_request_valid" time="0.411"><failure message="AttributeError: 'AdapterSwitchRequest' object has no attribute 'unload_previous'">self = &lt;test_schemas.TestModelSchemas object at 0x7fa35df1cf40&gt;

    def test_adapter_switch_request_valid(self):
        """测试有效的适配器切换请求"""
        request = AdapterSwitchRequest(
            from_adapter_id="adapter-1",
            to_adapter_id="adapter-2",
            unload_previous=True,
            config={
                "temperature": 0.7
            }
        )
    
        assert request.from_adapter_id == "adapter-1"
        assert request.to_adapter_id == "adapter-2"
&gt;       assert request.unload_previous is True

tests/unit/api/test_schemas.py:407: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = AdapterSwitchRequest(from_adapter_id='adapter-1', to_adapter_id='adapter-2', config_override=None, timeout=30)
item = 'unload_previous'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'AdapterSwitchRequest' object has no attribute 'unload_previous'

/root/miniconda3/lib/python3.8/site-packages/pydantic/main.py:891: AttributeError</failure></testcase><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_system_info_valid" time="0.387"><failure message="NameError: name 'SystemInfo' is not defined">self = &lt;test_schemas.TestModelSchemas object at 0x7fa35df216d0&gt;

    def test_system_info_valid(self):
        """测试有效的系统信息"""
&gt;       info = SystemInfo(
            cpu_usage=45.2,
            memory_usage=60.8,
            disk_usage=75.0,
            gpu_usage={
                "cuda:0": 80.5,
                "cuda:1": 65.3
            },
            temperature={
                "cpu": 65.0,
                "gpu": 78.0
            },
            uptime_seconds=3600.0,
            timestamp=datetime.now(timezone.utc)
        )
E       NameError: name 'SystemInfo' is not defined

tests/unit/api/test_schemas.py:442: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestModelSchemas" name="test_adapter_load_request_valid" time="0.386"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for AdapterLoadRequest&#10;adapter_id&#10;  Field required [type=missing, input_value={'adapter_path': '/path/t...lse, 'async_load': True}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing">self = &lt;test_schemas.TestModelSchemas object at 0x7fa35df1c580&gt;

    def test_adapter_load_request_valid(self):
        """测试有效的适配器加载请求"""
&gt;       request = AdapterLoadRequest(
            adapter_path="/path/to/adapter.bin",
            adapter_name="my-adapter",
            config={
                "temperature": 0.8,
                "top_p": 0.9
            },
            force_reload=False,
            async_load=True
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for AdapterLoadRequest
E       adapter_id
E         Field required [type=missing, input_value={'adapter_path': '/path/t...lse, 'async_load': True}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing

tests/unit/api/test_schemas.py:350: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestHealthSchemas" name="test_system_metrics_valid" time="0.382"><failure message="pydantic_core._pydantic_core.ValidationError: 4 validation errors for SystemMetrics&#10;cpu_usage&#10;  Field required [type=missing, input_value={'cpu_percent': 45.2, 'me...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;memory_usage&#10;  Field required [type=missing, input_value={'cpu_percent': 45.2, 'me...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;disk_usage&#10;  Field required [type=missing, input_value={'cpu_percent': 45.2, 'me...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing&#10;uptime&#10;  Field required [type=missing, input_value={'cpu_percent': 45.2, 'me...=datetime.timezone.utc)}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/missing">self = &lt;test_schemas.TestHealthSchemas object at 0x7fa35df17a30&gt;

    def test_system_metrics_valid(self):
        """测试有效的系统指标"""
&gt;       metrics = SystemMetrics(
            cpu_percent=45.2,
            memory_percent=68.5,
            disk_percent=75.0,
            network_io={
                "bytes_sent": 1024*1024*100,
                "bytes_recv": 1024*1024*200
            },
            process_count=156,
            load_average=[1.2, 1.5, 1.8],
            timestamp=datetime.now(timezone.utc)
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for SystemMetrics
E       cpu_usage
E         Field required [type=missing, input_value={'cpu_percent': 45.2, 'me...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       memory_usage
E         Field required [type=missing, input_value={'cpu_percent': 45.2, 'me...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       disk_usage
E         Field required [type=missing, input_value={'cpu_percent': 45.2, 'me...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing
E       uptime
E         Field required [type=missing, input_value={'cpu_percent': 45.2, 'me...=datetime.timezone.utc)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.10/v/missing

tests/unit/api/test_schemas.py:505: ValidationError</failure></testcase><testcase classname="unit.api.test_schemas.TestHealthSchemas" name="test_component_health_valid" time="0.476"><failure message="NameError: name 'ComponentHealth' is not defined">self = &lt;test_schemas.TestHealthSchemas object at 0x7fa35df21b50&gt;

    def test_component_health_valid(self):
        """测试有效的组件健康状态"""
&gt;       health = ComponentHealth(
            name="database",
            status="healthy",
            message="Connection successful",
            response_time_ms=25.5,
            last_check=datetime.now(timezone.utc),
            details={
                "connection_pool": "active",
                "query_count": 1250
            }
        )
E       NameError: name 'ComponentHealth' is not defined

tests/unit/api/test_schemas.py:471: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestHealthSchemas" name="test_deep_health_check_response_valid" time="0.404"><failure message="NameError: name 'ComponentHealth' is not defined">self = &lt;test_schemas.TestHealthSchemas object at 0x7fa35df21280&gt;

    def test_deep_health_check_response_valid(self):
        """测试有效的深度健康检查响应"""
        components = [
&gt;           ComponentHealth(
                name="database",
                status="healthy",
                message="OK",
                response_time_ms=25.0,
                last_check=datetime.now(timezone.utc)
            ),
            ComponentHealth(
                name="redis",
                status="degraded",
                message="High latency",
                response_time_ms=150.0,
                last_check=datetime.now(timezone.utc)
            )
        ]
E       NameError: name 'ComponentHealth' is not defined

tests/unit/api/test_schemas.py:539: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestHealthSchemas" name="test_component_health_unhealthy" time="0.330"><failure message="NameError: name 'ComponentHealth' is not defined">self = &lt;test_schemas.TestHealthSchemas object at 0x7fa35df1c8e0&gt;

    def test_component_health_unhealthy(self):
        """测试不健康的组件状态"""
&gt;       health = ComponentHealth(
            name="redis",
            status="unhealthy",
            message="Connection timeout",
            response_time_ms=5000.0,
            last_check=datetime.now(timezone.utc),
            error="ConnectionTimeoutError: Unable to connect"
        )
E       NameError: name 'ComponentHealth' is not defined

tests/unit/api/test_schemas.py:490: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestHealthSchemas" name="test_health_check_response_valid" time="0.451"><failure message="NameError: name 'HealthCheckResponse' is not defined">self = &lt;test_schemas.TestHealthSchemas object at 0x7fa35df06970&gt;

    def test_health_check_response_valid(self):
        """测试有效的健康检查响应"""
&gt;       response = HealthCheckResponse(
            status="healthy",
            timestamp=datetime.now(timezone.utc),
            uptime_seconds=7200.0,
            version="1.0.0"
        )
E       NameError: name 'HealthCheckResponse' is not defined

tests/unit/api/test_schemas.py:525: NameError</failure></testcase><testcase classname="unit.api.test_schemas.TestSchemaPerformance" name="test_message_creation_performance" time="0.413" /><testcase classname="unit.api.test_schemas.TestSchemaPerformance" name="test_serialization_performance" time="0.403"><failure message="pydantic_core._pydantic_core.ValidationError: 100 validation errors for ChatCompletionRequest&#10;messages.0&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='11e11c13-190e...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.1&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='5d5c1292-5e4b...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.2&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='9f8eb4d8-9368...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.3&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='7cce2ea7-b2a2...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.4&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='92faf0ec-dff4...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.5&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='4b307ecc-d421...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.6&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='15eb5941-5fa1...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.7&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='c2fe6530-2c39...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.8&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='43f765bc-cc34...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.9&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='41bb6d27-52e3...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.10&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='f7bfd54f-aaf2...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.11&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='205b3280-e2e0...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.12&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='380846ff-7118...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.13&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='51d60c2c-c353...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.14&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='50dfc680-3747...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.15&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='d4fa67b9-cbb7...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.16&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='d3db4e87-4d42...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.17&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='2f7c9020-b0ff...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.18&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='80a98fad-9aea...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.19&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='03284851-0bc9...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.20&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='66712a13-2d4e...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.21&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='6f135833-3d1d...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.22&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='323e3007-ed5e...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.23&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='f2383106-964a...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.24&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='a326cde2-143a...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.25&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='eccc8758-b8ba...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.26&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='c403d36d-a5e9...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.27&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='d1e67475-97bd...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.28&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='215b8134-d217...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.29&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='907a91e6-ba30...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.30&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='ee07f9ea-42bb...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.31&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='aff22321-bb3a...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.32&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='64377869-7ab5...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.33&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='cd525535-5785...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.34&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='5a4420a9-7490...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.35&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='c7419c03-3cc4...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.36&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='0e09e3b1-9db1...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.37&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='1fbd163a-a45f...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.38&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='6666b570-b396...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.39&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='a95af458-cc51...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.40&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='af68c6db-59e9...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.41&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='47810c19-31b2...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.42&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='4a82cbbc-2a98...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.43&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='31da6a86-2291...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.44&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='cd69efc1-af4e...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.45&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='f80745fc-4840...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.46&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='39d9e08e-8cab...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.47&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='26523c8e-8525...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.48&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='8192868d-6e50...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.49&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='3374c3c9-b299...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.50&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='796c4e09-c9d8...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.51&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='0b707eb8-4370...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.52&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='6cebc00b-320f...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.53&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='082b24f6-afb8...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.54&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='0da7317b-d4f1...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.55&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='3e30512d-3b60...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.56&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='d31174be-1776...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.57&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='bc748bc9-7494...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.58&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='773e587e-ca7b...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.59&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='d26be15f-df44...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.60&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='fff72610-adc4...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.61&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='d80642a6-ba77...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.62&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='d13073d8-9004...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.63&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='0fa5f6da-02ef...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.64&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='340427a5-687a...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.65&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='cfd68a92-6a7a...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.66&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='32b19ac5-46f0...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.67&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='e11d7e7e-e278...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.68&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='8299a145-dc7e...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.69&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='5f99e176-ab50...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.70&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='e3a82bbc-72b3...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.71&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='a1b5c416-c60b...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.72&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='94196a9c-747d...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.73&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='1c99528e-30b2...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.74&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='50a88df3-6b49...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.75&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='a04cae94-925c...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.76&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='1edef483-8a43...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.77&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='c416ece6-0beb...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.78&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='b0221f19-5565...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.79&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='ae81f09e-eae7...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.80&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='7c66db8a-f05a...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.81&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='d497edc5-a86e...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.82&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='097863a3-54e6...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.83&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='65f20062-13fa...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.84&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='31a13620-2231...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.85&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='ae1412cf-8751...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.86&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='c6762173-cf04...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.87&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='22eb45b4-29f5...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.88&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='ef8f5b48-bcd2...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.89&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='3b8c5a7e-4975...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.90&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='fabded5b-9316...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.91&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='ea49820f-2dc3...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.92&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='57754ee5-0239...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.93&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='7f686522-ed31...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.94&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='5b477c0b-e41d...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.95&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='8926bb4f-1ca0...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.96&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='ba834f2b-85ea...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.97&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='504c57ed-2ab6...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.98&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='8c7d329d-7b8c...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type&#10;messages.99&#10;  Input should be a valid dictionary [type=dict_type, input_value=Message(id='36d633b0-8bdc...e, processing_time=None), input_type=Message]&#10;    For further information visit https://errors.pydantic.dev/2.10/v/dict_type">self = &lt;test_schemas.TestSchemaPerformance object at 0x7fa35df1c130&gt;

    def test_serialization_performance(self):
        """测试序列化性能"""
        import time
    
        # 创建复杂的数据结构
        messages = [
            Message(
                role=MessageRole.USER,
                content=f"Message {i}",
                timestamp=datetime.now(timezone.utc),
                metadata={"index": i, "type": "test"}
            )
            for i in range(100)
        ]
    
&gt;       request = ChatCompletionRequest(
            messages=messages,
            model="gpt-3.5-turbo",
            temperature=0.7,
            max_tokens=1000
        )
E       pydantic_core._pydantic_core.ValidationError: 100 validation errors for ChatCompletionRequest
E       messages.0
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='11e11c13-190e...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.1
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='5d5c1292-5e4b...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.2
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='9f8eb4d8-9368...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.3
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='7cce2ea7-b2a2...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.4
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='92faf0ec-dff4...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.5
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='4b307ecc-d421...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.6
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='15eb5941-5fa1...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.7
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='c2fe6530-2c39...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.8
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='43f765bc-cc34...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.9
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='41bb6d27-52e3...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.10
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='f7bfd54f-aaf2...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.11
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='205b3280-e2e0...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.12
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='380846ff-7118...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.13
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='51d60c2c-c353...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.14
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='50dfc680-3747...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.15
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='d4fa67b9-cbb7...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.16
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='d3db4e87-4d42...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.17
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='2f7c9020-b0ff...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.18
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='80a98fad-9aea...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.19
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='03284851-0bc9...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.20
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='66712a13-2d4e...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.21
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='6f135833-3d1d...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.22
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='323e3007-ed5e...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.23
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='f2383106-964a...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.24
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='a326cde2-143a...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.25
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='eccc8758-b8ba...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.26
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='c403d36d-a5e9...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.27
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='d1e67475-97bd...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.28
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='215b8134-d217...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.29
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='907a91e6-ba30...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.30
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='ee07f9ea-42bb...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.31
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='aff22321-bb3a...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.32
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='64377869-7ab5...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.33
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='cd525535-5785...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.34
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='5a4420a9-7490...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.35
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='c7419c03-3cc4...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.36
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='0e09e3b1-9db1...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.37
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='1fbd163a-a45f...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.38
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='6666b570-b396...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.39
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='a95af458-cc51...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.40
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='af68c6db-59e9...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.41
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='47810c19-31b2...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.42
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='4a82cbbc-2a98...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.43
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='31da6a86-2291...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.44
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='cd69efc1-af4e...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.45
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='f80745fc-4840...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.46
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='39d9e08e-8cab...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.47
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='26523c8e-8525...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.48
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='8192868d-6e50...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.49
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='3374c3c9-b299...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.50
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='796c4e09-c9d8...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.51
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='0b707eb8-4370...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.52
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='6cebc00b-320f...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.53
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='082b24f6-afb8...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.54
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='0da7317b-d4f1...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.55
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='3e30512d-3b60...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.56
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='d31174be-1776...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.57
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='bc748bc9-7494...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.58
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='773e587e-ca7b...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.59
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='d26be15f-df44...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.60
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='fff72610-adc4...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.61
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='d80642a6-ba77...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.62
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='d13073d8-9004...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.63
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='0fa5f6da-02ef...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.64
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='340427a5-687a...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.65
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='cfd68a92-6a7a...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.66
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='32b19ac5-46f0...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.67
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='e11d7e7e-e278...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.68
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='8299a145-dc7e...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.69
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='5f99e176-ab50...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.70
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='e3a82bbc-72b3...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.71
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='a1b5c416-c60b...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.72
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='94196a9c-747d...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.73
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='1c99528e-30b2...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.74
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='50a88df3-6b49...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.75
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='a04cae94-925c...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.76
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='1edef483-8a43...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.77
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='c416ece6-0beb...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.78
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='b0221f19-5565...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.79
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='ae81f09e-eae7...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.80
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='7c66db8a-f05a...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.81
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='d497edc5-a86e...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.82
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='097863a3-54e6...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.83
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='65f20062-13fa...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.84
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='31a13620-2231...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.85
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='ae1412cf-8751...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.86
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='c6762173-cf04...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.87
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='22eb45b4-29f5...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.88
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='ef8f5b48-bcd2...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.89
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='3b8c5a7e-4975...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.90
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='fabded5b-9316...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.91
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='ea49820f-2dc3...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.92
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='57754ee5-0239...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.93
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='7f686522-ed31...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.94
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='5b477c0b-e41d...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.95
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='8926bb4f-1ca0...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.96
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='ba834f2b-85ea...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.97
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='504c57ed-2ab6...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.98
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='8c7d329d-7b8c...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type
E       messages.99
E         Input should be a valid dictionary [type=dict_type, input_value=Message(id='36d633b0-8bdc...e, processing_time=None), input_type=Message]
E           For further information visit https://errors.pydantic.dev/2.10/v/dict_type

tests/unit/api/test_schemas.py:834: ValidationError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatMemoryManagement" name="test_memory_cleanup_trigger" time="0.400"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_memory_cleanup_trigger&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatMemoryManagement" name="test_memory_usage_tracking" time="0.488" /><testcase classname="unit.api.test_chat_routes.TestChatUtilities" name="test_message_with_emotion" time="0.725" /><testcase classname="unit.api.test_chat_routes.TestChatUtilities" name="test_message_creation" time="0.409" /><testcase classname="unit.api.test_chat_routes.TestChatUtilities" name="test_message_validation" time="0.386" /><testcase classname="unit.api.test_chat_routes.TestChatUtilities" name="test_message_with_multimedia" time="0.337" /><testcase classname="unit.api.test_chat_routes.TestChatUtilities" name="test_message_metadata" time="0.380" /><testcase classname="unit.api.test_chat_routes.TestChatPerformance" name="test_memory_usage_during_processing" time="0.798" /><testcase classname="unit.api.test_chat_routes.TestChatPerformance" name="test_request_processing_speed" time="0.395"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_request_processing_speed&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatPerformance" name="test_throughput_performance" time="0.391"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_throughput_performance&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatRequestModels" name="test_chat_request_valid" time="0.392" /><testcase classname="unit.api.test_chat_routes.TestChatRequestModels" name="test_chat_request_with_optional_fields" time="0.386" /><testcase classname="unit.api.test_chat_routes.TestChatRequestModels" name="test_chat_request_temperature_validation" time="0.330" /><testcase classname="unit.api.test_chat_routes.TestChatRequestModels" name="test_emotion_chat_request_valid" time="0.472" /><testcase classname="unit.api.test_chat_routes.TestChatRequestModels" name="test_emotion_intensity_validation" time="0.423" /><testcase classname="unit.api.test_chat_routes.TestChatRequestModels" name="test_stream_chat_request_length_validation" time="0.396" /><testcase classname="unit.api.test_chat_routes.TestChatRequestModels" name="test_stream_chat_request_valid" time="0.392" /><testcase classname="unit.api.test_chat_routes.TestChatRouteLogic" name="test_adapter_selection" time="0.377" /><testcase classname="unit.api.test_chat_routes.TestChatRouteLogic" name="test_emotion_chat_flow" time="0.478"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_emotion_chat_flow&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatRouteLogic" name="test_chat_completion_basic_flow" time="0.399"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_chat_completion_basic_flow&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatRouteLogic" name="test_session_id_generation" time="0.401" /><testcase classname="unit.api.test_chat_routes.TestChatRouteLogic" name="test_character_integration" time="0.477" /><testcase classname="unit.api.test_chat_routes.TestChatRouteLogic" name="test_stream_chat_flow" time="0.505"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_stream_chat_flow&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatRouteLogic" name="test_error_handling_scenarios" time="0.399"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">self = &lt;test_chat_routes.TestChatRouteLogic object at 0x7fa35e354760&gt;

    def test_error_handling_scenarios(self):
        """测试错误处理场景"""
        # 空消息列表
        with pytest.raises(ValueError):
&gt;           ChatRequest(messages=[])
E           Failed: DID NOT RAISE &lt;class 'ValueError'&gt;

tests/unit/api/test_chat_routes.py:441: Failed</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatRouteIntegration" name="test_stream_endpoint_integration" time="0.408"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_routes.py:548: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_chat_routes.TestChatRouteIntegration" name="test_emotion_endpoint_integration" time="0.500"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_routes.py:552: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_chat_routes.TestChatRouteIntegration" name="test_chat_endpoint_integration" time="0.387"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_routes.py:544: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_chat_routes.TestChatEdgeCases" name="test_special_characters_in_content" time="0.512" /><testcase classname="unit.api.test_chat_routes.TestChatEdgeCases" name="test_maximum_messages_limit" time="0.571" /><testcase classname="unit.api.test_chat_routes.TestChatEdgeCases" name="test_unicode_model_name" time="0.409" /><testcase classname="unit.api.test_chat_routes.TestChatEdgeCases" name="test_very_long_message_content" time="0.483" /><testcase classname="unit.api.test_chat_routes.TestChatEdgeCases" name="test_empty_message_content" time="0.341" /><testcase classname="unit.api.test_chat_routes.TestChatEdgeCases" name="test_max_tokens_boundary_values" time="0.403" /><testcase classname="unit.api.test_chat_routes.TestChatEdgeCases" name="test_temperature_boundary_values" time="0.336" /><testcase classname="unit.api.test_chat_routes.TestChatConcurrency" name="test_concurrent_requests" time="0.407"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_concurrent_requests&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatConcurrency" name="test_request_queuing" time="0.346"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_request_queuing&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatStreamHandling" name="test_stream_error_handling" time="0.493"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_stream_error_handling&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatStreamHandling" name="test_stream_response_chunks" time="0.333"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_stream_response_chunks&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatStreamHandling" name="test_stream_empty_response" time="0.510"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_stream_empty_response&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatResponseModels" name="test_stream_chunk_creation" time="0.387" /><testcase classname="unit.api.test_chat_routes.TestChatResponseModels" name="test_chat_usage_creation" time="0.395" /><testcase classname="unit.api.test_chat_routes.TestChatResponseModels" name="test_history_response_creation" time="0.400" /><testcase classname="unit.api.test_chat_routes.TestChatResponseModels" name="test_emotion_response_creation" time="0.391"><failure message="AttributeError: EMPATHETIC">self = &lt;test_chat_routes.TestChatResponseModels object at 0x7fa35e346df0&gt;

    def test_emotion_response_creation(self):
        """测试情绪响应创建"""
        message = Message(
            role=MessageRole.ASSISTANT,
            content="I understand you're feeling sad.",
&gt;           emotion=EmotionType.EMPATHETIC
        )

tests/unit/api/test_chat_routes.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;enum 'EmotionType'&gt;, name = 'EMPATHETIC'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
&gt;           raise AttributeError(name) from None
E           AttributeError: EMPATHETIC

/root/miniconda3/lib/python3.8/enum.py:384: AttributeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatResponseModels" name="test_chat_completion_response_creation" time="0.395" /><testcase classname="unit.api.test_chat_routes.TestChatResponseModels" name="test_chat_choice_creation" time="0.385" /><testcase classname="unit.api.test_chat_routes.TestChatErrorHandling" name="test_model_not_loaded_error" time="0.391"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_model_not_loaded_error&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatErrorHandling" name="test_negative_max_tokens" time="0.377"><failure message="Failed: DID NOT RAISE &lt;class 'Exception'&gt;">self = &lt;test_chat_routes.TestChatErrorHandling object at 0x7fa35e235100&gt;

    def test_negative_max_tokens(self):
        """测试负最大令牌数"""
        with pytest.raises(Exception):  # 应该是ValidationError
&gt;           ChatRequest(
                messages=[{"role": "user", "content": "test"}],
                model="test-model",
                max_tokens=-1
            )
E           Failed: DID NOT RAISE &lt;class 'Exception'&gt;

tests/unit/api/test_chat_routes.py:731: Failed</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatErrorHandling" name="test_invalid_message_role" time="0.385"><failure message="Failed: DID NOT RAISE &lt;class 'Exception'&gt;">self = &lt;test_chat_routes.TestChatErrorHandling object at 0x7fa35e354f10&gt;

    def test_invalid_message_role(self):
        """测试无效的消息角色"""
        with pytest.raises(Exception):  # 应该是ValidationError
&gt;           ChatRequest(
                messages=[{"role": "invalid_role", "content": "test"}],
                model="test-model"
            )
E           Failed: DID NOT RAISE &lt;class 'Exception'&gt;

tests/unit/api/test_chat_routes.py:714: Failed</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatErrorHandling" name="test_invalid_json_request" time="0.496"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_chat_routes.py:701: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_chat_routes.TestChatErrorHandling" name="test_model_generation_error" time="0.464"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_model_generation_error&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatErrorHandling" name="test_request_timeout_error" time="0.381"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_request_timeout_error&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_chat_routes.TestChatErrorHandling" name="test_negative_temperature" time="0.325" /><testcase classname="unit.api.test_chat_routes.TestChatErrorHandling" name="test_missing_required_fields" time="0.385" /><testcase classname="integration.test_full_system.TestAdapterIntegration" name="test_adapter_registration_and_usage" time="0.395"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 183&#10;      @pytest.mark.asyncio&#10;      async def test_adapter_registration_and_usage(self, adapter_registry, mock_adapter_class):&#10;          &quot;&quot;&quot;测试适配器注册和使用&quot;&quot;&quot;&#10;          # 注册适配器&#10;          registration = await adapter_registry.register_adapter(&#10;              &quot;mock-adapter&quot;,&#10;              mock_adapter_class,&#10;              {&quot;timeout&quot;: 30}&#10;          )&#10;&#10;          assert registration.adapter_id == &quot;mock-adapter&quot;&#10;&#10;          # 获取适配器&#10;          adapter = await adapter_registry.get_adapter(&quot;mock-adapter&quot;)&#10;          assert adapter is not None&#10;&#10;          # 执行适配器&#10;          context = ExecutionContext(&#10;              user_id=&quot;test-user&quot;,&#10;              session_id=&quot;test-session&quot;&#10;          )&#10;&#10;          result = await adapter_registry.execute_adapter(&#10;              &quot;mock-adapter&quot;,&#10;              &quot;Test input message&quot;,&#10;              context&#10;          )&#10;&#10;          assert isinstance(result, ExecutionResult)&#10;          assert result.status == &quot;success&quot;&#10;          assert &quot;Mock response&quot; in result.output&#10;          assert &quot;Test input message&quot; in result.output&#10;E       fixture 'adapter_registry' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestAdapterIntegration::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:183&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 183
      @pytest.mark.asyncio
      async def test_adapter_registration_and_usage(self, adapter_registry, mock_adapter_class):
          """测试适配器注册和使用"""
          # 注册适配器
          registration = await adapter_registry.register_adapter(
              "mock-adapter",
              mock_adapter_class,
              {"timeout": 30}
          )

          assert registration.adapter_id == "mock-adapter"

          # 获取适配器
          adapter = await adapter_registry.get_adapter("mock-adapter")
          assert adapter is not None

          # 执行适配器
          context = ExecutionContext(
              user_id="test-user",
              session_id="test-session"
          )

          result = await adapter_registry.execute_adapter(
              "mock-adapter",
              "Test input message",
              context
          )

          assert isinstance(result, ExecutionResult)
          assert result.status == "success"
          assert "Mock response" in result.output
          assert "Test input message" in result.output
E       fixture 'adapter_registry' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestAdapterIntegration::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:183</error></testcase><testcase classname="integration.test_full_system.TestAdapterIntegration" name="test_multiple_adapter_coordination" time="0.378"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 216&#10;      @pytest.mark.asyncio&#10;      async def test_multiple_adapter_coordination(self, adapter_registry, mock_adapter_class):&#10;          &quot;&quot;&quot;测试多个适配器协调工作&quot;&quot;&quot;&#10;          # 注册多个适配器&#10;          for i in range(3):&#10;              await adapter_registry.register_adapter(&#10;                  f&quot;mock-adapter-{i}&quot;,&#10;                  mock_adapter_class,&#10;                  {&quot;timeout&quot;: 30, &quot;adapter_id&quot;: i}&#10;              )&#10;&#10;          # 验证所有适配器都已注册&#10;          adapters = await adapter_registry.list_adapters()&#10;          assert len(adapters) == 3&#10;&#10;          # 并发执行多个适配器&#10;          context = ExecutionContext(user_id=&quot;test-user&quot;)&#10;&#10;          tasks = []&#10;          for i in range(3):&#10;              task = adapter_registry.execute_adapter(&#10;                  f&quot;mock-adapter-{i}&quot;,&#10;                  f&quot;Input for adapter {i}&quot;,&#10;                  context&#10;              )&#10;              tasks.append(task)&#10;&#10;          results = await asyncio.gather(*tasks)&#10;&#10;          # 验证所有结果&#10;          assert len(results) == 3&#10;          for i, result in enumerate(results):&#10;              assert result.status == &quot;success&quot;&#10;              assert f&quot;Input for adapter {i}&quot; in result.output&#10;E       fixture 'adapter_registry' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestAdapterIntegration::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:216&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 216
      @pytest.mark.asyncio
      async def test_multiple_adapter_coordination(self, adapter_registry, mock_adapter_class):
          """测试多个适配器协调工作"""
          # 注册多个适配器
          for i in range(3):
              await adapter_registry.register_adapter(
                  f"mock-adapter-{i}",
                  mock_adapter_class,
                  {"timeout": 30, "adapter_id": i}
              )

          # 验证所有适配器都已注册
          adapters = await adapter_registry.list_adapters()
          assert len(adapters) == 3

          # 并发执行多个适配器
          context = ExecutionContext(user_id="test-user")

          tasks = []
          for i in range(3):
              task = adapter_registry.execute_adapter(
                  f"mock-adapter-{i}",
                  f"Input for adapter {i}",
                  context
              )
              tasks.append(task)

          results = await asyncio.gather(*tasks)

          # 验证所有结果
          assert len(results) == 3
          for i, result in enumerate(results):
              assert result.status == "success"
              assert f"Input for adapter {i}" in result.output
E       fixture 'adapter_registry' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestAdapterIntegration::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:216</error></testcase><testcase classname="integration.test_full_system.TestPerformanceAndReliability" name="test_memory_usage_stability" time="0.331"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 526&#10;      @pytest.mark.asyncio&#10;      async def test_memory_usage_stability(self, adapter_registry, mock_adapter_class):&#10;          &quot;&quot;&quot;测试内存使用稳定性&quot;&quot;&quot;&#10;          # 注册适配器&#10;          await adapter_registry.register_adapter(&#10;              &quot;memory-test-adapter&quot;,&#10;              mock_adapter_class,&#10;              {&quot;timeout&quot;: 30}&#10;          )&#10;&#10;          # 执行大量操作&#10;          context = ExecutionContext(user_id=&quot;test-user&quot;)&#10;&#10;          for i in range(100):&#10;              result = await adapter_registry.execute_adapter(&#10;                  &quot;memory-test-adapter&quot;,&#10;                  f&quot;Test message {i}&quot;,&#10;                  context&#10;              )&#10;              assert result.status == &quot;success&quot;&#10;&#10;          # 验证适配器仍然健康&#10;          health_result = await adapter_registry.health_check_adapter(&quot;memory-test-adapter&quot;)&#10;          assert health_result.is_healthy is True&#10;E       fixture 'adapter_registry' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestPerformanceAndReliability::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:526&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 526
      @pytest.mark.asyncio
      async def test_memory_usage_stability(self, adapter_registry, mock_adapter_class):
          """测试内存使用稳定性"""
          # 注册适配器
          await adapter_registry.register_adapter(
              "memory-test-adapter",
              mock_adapter_class,
              {"timeout": 30}
          )

          # 执行大量操作
          context = ExecutionContext(user_id="test-user")

          for i in range(100):
              result = await adapter_registry.execute_adapter(
                  "memory-test-adapter",
                  f"Test message {i}",
                  context
              )
              assert result.status == "success"

          # 验证适配器仍然健康
          health_result = await adapter_registry.health_check_adapter("memory-test-adapter")
          assert health_result.is_healthy is True
E       fixture 'adapter_registry' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestPerformanceAndReliability::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:526</error></testcase><testcase classname="integration.test_full_system.TestPerformanceAndReliability" name="test_concurrent_requests" time="0.335"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 449&#10;      @pytest.mark.asyncio&#10;      async def test_concurrent_requests(self, test_client, sample_character_config):&#10;          &quot;&quot;&quot;测试并发请求处理&quot;&quot;&quot;&#10;          # 准备多个并发请求&#10;          requests = []&#10;          for i in range(10):&#10;              request = {&#10;                  &quot;character_id&quot;: sample_character_config.id,&#10;                  &quot;message&quot;: f&quot;Test message {i}&quot;,&#10;                  &quot;context&quot;: {&quot;request_id&quot;: i}&#10;              }&#10;              requests.append(request)&#10;&#10;          # 模拟并发API调用&#10;          async def mock_api_call(request_data):&#10;              # 模拟处理时间&#10;              await asyncio.sleep(0.1)&#10;              return {&#10;                  &quot;success&quot;: True,&#10;                  &quot;response&quot;: f&quot;Response to: {request_data['message']}&quot;,&#10;                  &quot;processing_time&quot;: 0.1&#10;              }&#10;&#10;          # 执行并发请求&#10;          start_time = time.time()&#10;          tasks = [mock_api_call(req) for req in requests]&#10;          results = await asyncio.gather(*tasks)&#10;          end_time = time.time()&#10;&#10;          # 验证结果&#10;          assert len(results) == 10&#10;          for i, result in enumerate(results):&#10;              assert result[&quot;success&quot;] is True&#10;              assert f&quot;Test message {i}&quot; in result[&quot;response&quot;]&#10;&#10;          # 验证并发性能（应该比串行快）&#10;          total_time = end_time - start_time&#10;          assert total_time &lt; 0.5  # 应该远小于1秒（10 * 0.1）&#10;E       fixture 'test_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestPerformanceAndReliability::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:449&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 449
      @pytest.mark.asyncio
      async def test_concurrent_requests(self, test_client, sample_character_config):
          """测试并发请求处理"""
          # 准备多个并发请求
          requests = []
          for i in range(10):
              request = {
                  "character_id": sample_character_config.id,
                  "message": f"Test message {i}",
                  "context": {"request_id": i}
              }
              requests.append(request)

          # 模拟并发API调用
          async def mock_api_call(request_data):
              # 模拟处理时间
              await asyncio.sleep(0.1)
              return {
                  "success": True,
                  "response": f"Response to: {request_data['message']}",
                  "processing_time": 0.1
              }

          # 执行并发请求
          start_time = time.time()
          tasks = [mock_api_call(req) for req in requests]
          results = await asyncio.gather(*tasks)
          end_time = time.time()

          # 验证结果
          assert len(results) == 10
          for i, result in enumerate(results):
              assert result["success"] is True
              assert f"Test message {i}" in result["response"]

          # 验证并发性能（应该比串行快）
          total_time = end_time - start_time
          assert total_time &lt; 0.5  # 应该远小于1秒（10 * 0.1）
E       fixture 'test_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestPerformanceAndReliability::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:449</error></testcase><testcase classname="integration.test_full_system.TestPerformanceAndReliability" name="test_error_recovery" time="0.381"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 488&#10;      @pytest.mark.asyncio&#10;      async def test_error_recovery(self, adapter_registry, mock_adapter_class):&#10;          &quot;&quot;&quot;测试错误恢复机制&quot;&quot;&quot;&#10;          # 创建会失败的适配器&#10;          class FailingAdapter(mock_adapter_class):&#10;              def __init__(self, config):&#10;E       fixture 'adapter_registry' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestPerformanceAndReliability::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:488&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 488
      @pytest.mark.asyncio
      async def test_error_recovery(self, adapter_registry, mock_adapter_class):
          """测试错误恢复机制"""
          # 创建会失败的适配器
          class FailingAdapter(mock_adapter_class):
              def __init__(self, config):
E       fixture 'adapter_registry' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestPerformanceAndReliability::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:488</error></testcase><testcase classname="integration.test_full_system.TestSystemConfiguration" name="test_health_monitoring_integration" time="0.330"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_health_monitoring_integration&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="integration.test_full_system.TestSystemConfiguration" name="test_development_environment_setup" time="0.479"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;test_full_system.TestSystemConfiguration object at 0x7fa365cf3610&gt;

    def test_development_environment_setup(self):
        """测试开发环境设置"""
        from zishu.adapters.base import create_development_registry
    
&gt;       registry = create_development_registry()

tests/integration/test_full_system.py:561: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/__init__.py:156: in create_development_registry
    return create_adapter_registry(
zishu/adapters/base/registry.py:1361: in create_adapter_registry
    return AdapterRegistry(
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="integration.test_full_system.TestSystemConfiguration" name="test_production_environment_setup" time="0.389"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;test_full_system.TestSystemConfiguration object at 0x7fa365ceb3a0&gt;

    def test_production_environment_setup(self):
        """测试生产环境设置"""
        from zishu.adapters.base import create_production_registry
    
&gt;       registry = create_production_registry()

tests/integration/test_full_system.py:573: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
zishu/adapters/base/__init__.py:146: in create_production_registry
    return create_adapter_registry(
zishu/adapters/base/registry.py:1361: in create_adapter_registry
    return AdapterRegistry(
zishu/adapters/base/registry.py:609: in __init__
    self.metadata_manager = metadata_manager or get_default_metadata_manager()
zishu/adapters/base/metadata.py:1388: in get_default_metadata_manager
    _default_manager = create_metadata_manager()
zishu/adapters/base/metadata.py:1369: in create_metadata_manager
    storage = FileSystemMetadataStorage(storage_path)
zishu/adapters/base/metadata.py:460: in __init__
    self._lock = asyncio.Lock()
/root/miniconda3/lib/python3.8/asyncio/locks.py:164: in __init__
    self._loop = events.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="integration.test_full_system.TestCharacterLifecycle" name="test_create_character_full_flow" time="0.397"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 110&#10;      @pytest.mark.asyncio&#10;      async def test_create_character_full_flow(self, test_client, sample_character_config):&#10;          &quot;&quot;&quot;测试创建角色的完整流程&quot;&quot;&quot;&#10;          # 准备创建请求&#10;          create_request = CreateCharacterRequest(&#10;              name=sample_character_config.name,&#10;              display_name=sample_character_config.display_name,&#10;              description=sample_character_config.description,&#10;              personality_type=sample_character_config.personality_type&#10;          )&#10;&#10;          # 模拟API调用&#10;          with patch.object(test_client, 'post') as mock_post:&#10;              mock_post.return_value.status_code = 200&#10;              mock_post.return_value.json.return_value = {&#10;                  &quot;success&quot;: True,&#10;                  &quot;message&quot;: &quot;Character created successfully&quot;,&#10;                  &quot;character&quot;: sample_character_config.model_dump()&#10;              }&#10;&#10;              # 执行创建请求&#10;              response = test_client.post(&#10;                  &quot;/api/v1/character/create&quot;,&#10;                  json=create_request.model_dump()&#10;              )&#10;&#10;              # 验证响应&#10;              assert response.status_code == 200&#10;              response_data = response.json()&#10;              assert response_data[&quot;success&quot;] is True&#10;              assert response_data[&quot;character&quot;][&quot;name&quot;] == sample_character_config.name&#10;E       fixture 'test_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestCharacterLifecycle::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:110&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 110
      @pytest.mark.asyncio
      async def test_create_character_full_flow(self, test_client, sample_character_config):
          """测试创建角色的完整流程"""
          # 准备创建请求
          create_request = CreateCharacterRequest(
              name=sample_character_config.name,
              display_name=sample_character_config.display_name,
              description=sample_character_config.description,
              personality_type=sample_character_config.personality_type
          )

          # 模拟API调用
          with patch.object(test_client, 'post') as mock_post:
              mock_post.return_value.status_code = 200
              mock_post.return_value.json.return_value = {
                  "success": True,
                  "message": "Character created successfully",
                  "character": sample_character_config.model_dump()
              }

              # 执行创建请求
              response = test_client.post(
                  "/api/v1/character/create",
                  json=create_request.model_dump()
              )

              # 验证响应
              assert response.status_code == 200
              response_data = response.json()
              assert response_data["success"] is True
              assert response_data["character"]["name"] == sample_character_config.name
E       fixture 'test_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestCharacterLifecycle::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:110</error></testcase><testcase classname="integration.test_full_system.TestCharacterLifecycle" name="test_character_interaction_flow" time="0.385"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 142&#10;      @pytest.mark.asyncio&#10;      async def test_character_interaction_flow(self, test_client, sample_character_config):&#10;          &quot;&quot;&quot;测试角色交互流程&quot;&quot;&quot;&#10;          # 准备交互请求&#10;          interaction_request = CharacterInteractionRequest(&#10;              character_id=sample_character_config.id,&#10;              message=&quot;Hello, how are you today?&quot;,&#10;              context={&quot;session_id&quot;: &quot;test-session-123&quot;},&#10;              preferred_emotion=EmotionType.CHEERFUL&#10;          )&#10;&#10;          # 模拟API调用&#10;          with patch.object(test_client, 'post') as mock_post:&#10;              mock_post.return_value.status_code = 200&#10;              mock_post.return_value.json.return_value = {&#10;                  &quot;success&quot;: True,&#10;                  &quot;response&quot;: &quot;Hello! I'm doing great, thank you for asking!&quot;,&#10;                  &quot;emotion&quot;: &quot;cheerful&quot;,&#10;                  &quot;processing_time&quot;: 0.5,&#10;                  &quot;adapters_used&quot;: [&quot;mock-adapter&quot;]&#10;              }&#10;&#10;              # 执行交互请求&#10;              response = test_client.post(&#10;                  f&quot;/api/v1/character/{sample_character_config.id}/interact&quot;,&#10;                  json=interaction_request.model_dump()&#10;              )&#10;&#10;              # 验证响应&#10;              assert response.status_code == 200&#10;              response_data = response.json()&#10;              assert response_data[&quot;success&quot;] is True&#10;              assert &quot;great&quot; in response_data[&quot;response&quot;]&#10;              assert response_data[&quot;emotion&quot;] == &quot;cheerful&quot;&#10;E       fixture 'test_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestCharacterLifecycle::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:142&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 142
      @pytest.mark.asyncio
      async def test_character_interaction_flow(self, test_client, sample_character_config):
          """测试角色交互流程"""
          # 准备交互请求
          interaction_request = CharacterInteractionRequest(
              character_id=sample_character_config.id,
              message="Hello, how are you today?",
              context={"session_id": "test-session-123"},
              preferred_emotion=EmotionType.CHEERFUL
          )

          # 模拟API调用
          with patch.object(test_client, 'post') as mock_post:
              mock_post.return_value.status_code = 200
              mock_post.return_value.json.return_value = {
                  "success": True,
                  "response": "Hello! I'm doing great, thank you for asking!",
                  "emotion": "cheerful",
                  "processing_time": 0.5,
                  "adapters_used": ["mock-adapter"]
              }

              # 执行交互请求
              response = test_client.post(
                  f"/api/v1/character/{sample_character_config.id}/interact",
                  json=interaction_request.model_dump()
              )

              # 验证响应
              assert response.status_code == 200
              response_data = response.json()
              assert response_data["success"] is True
              assert "great" in response_data["response"]
              assert response_data["emotion"] == "cheerful"
E       fixture 'test_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestCharacterLifecycle::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:142</error></testcase><testcase classname="integration.test_full_system.TestEmotionSystem" name="test_emotion_analysis_and_response" time="0.326"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 364&#10;      @pytest.mark.asyncio&#10;      async def test_emotion_analysis_and_response(self, test_client, sample_character_config):&#10;          &quot;&quot;&quot;测试情绪分析和响应&quot;&quot;&quot;&#10;          # 情绪分析请求&#10;          analysis_request = {&#10;              &quot;text&quot;: &quot;I just got a promotion at work! I'm so excited!&quot;,&#10;              &quot;context&quot;: {&quot;conversation_turn&quot;: 1},&#10;              &quot;current_emotion&quot;: &quot;neutral&quot;&#10;          }&#10;&#10;          with patch.object(test_client, 'post') as mock_post:&#10;              mock_post.return_value.status_code = 200&#10;              mock_post.return_value.json.return_value = {&#10;                  &quot;success&quot;: True,&#10;                  &quot;detected_emotions&quot;: [&#10;                      {&quot;emotion&quot;: &quot;excited&quot;, &quot;confidence&quot;: 0.9},&#10;                      {&quot;emotion&quot;: &quot;happy&quot;, &quot;confidence&quot;: 0.8}&#10;                  ],&#10;                  &quot;primary_emotion&quot;: &quot;excited&quot;,&#10;                  &quot;confidence&quot;: 0.9,&#10;                  &quot;emotion_keywords&quot;: [&quot;promotion&quot;, &quot;excited&quot;],&#10;                  &quot;suggested_response_emotion&quot;: &quot;cheerful&quot;&#10;              }&#10;&#10;              # 执行情绪分析&#10;              response = test_client.post(&#10;                  &quot;/api/v1/emotion/analyze&quot;,&#10;                  json=analysis_request&#10;              )&#10;&#10;              # 验证分析结果&#10;              assert response.status_code == 200&#10;              response_data = response.json()&#10;              assert response_data[&quot;success&quot;] is True&#10;              assert response_data[&quot;primary_emotion&quot;] == &quot;excited&quot;&#10;              assert response_data[&quot;confidence&quot;] == 0.9&#10;              assert &quot;promotion&quot; in response_data[&quot;emotion_keywords&quot;]&#10;E       fixture 'test_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestEmotionSystem::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:364&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 364
      @pytest.mark.asyncio
      async def test_emotion_analysis_and_response(self, test_client, sample_character_config):
          """测试情绪分析和响应"""
          # 情绪分析请求
          analysis_request = {
              "text": "I just got a promotion at work! I'm so excited!",
              "context": {"conversation_turn": 1},
              "current_emotion": "neutral"
          }

          with patch.object(test_client, 'post') as mock_post:
              mock_post.return_value.status_code = 200
              mock_post.return_value.json.return_value = {
                  "success": True,
                  "detected_emotions": [
                      {"emotion": "excited", "confidence": 0.9},
                      {"emotion": "happy", "confidence": 0.8}
                  ],
                  "primary_emotion": "excited",
                  "confidence": 0.9,
                  "emotion_keywords": ["promotion", "excited"],
                  "suggested_response_emotion": "cheerful"
              }

              # 执行情绪分析
              response = test_client.post(
                  "/api/v1/emotion/analyze",
                  json=analysis_request
              )

              # 验证分析结果
              assert response.status_code == 200
              response_data = response.json()
              assert response_data["success"] is True
              assert response_data["primary_emotion"] == "excited"
              assert response_data["confidence"] == 0.9
              assert "promotion" in response_data["emotion_keywords"]
E       fixture 'test_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestEmotionSystem::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:364</error></testcase><testcase classname="integration.test_full_system.TestEmotionSystem" name="test_character_emotion_transition" time="0.381"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 402&#10;      @pytest.mark.asyncio&#10;      async def test_character_emotion_transition(self, test_client, sample_character_config):&#10;          &quot;&quot;&quot;测试角色情绪转换&quot;&quot;&quot;&#10;          # 设置情绪请求&#10;          emotion_request = {&#10;              &quot;emotion&quot;: &quot;excited&quot;,&#10;              &quot;intensity&quot;: 0.8,&#10;              &quot;duration&quot;: 300,&#10;              &quot;reason&quot;: &quot;User shared good news&quot;,&#10;              &quot;transition_type&quot;: &quot;gradual&quot;&#10;          }&#10;&#10;          with patch.object(test_client, 'post') as mock_post:&#10;              mock_post.return_value.status_code = 200&#10;              mock_post.return_value.json.return_value = {&#10;                  &quot;success&quot;: True,&#10;                  &quot;current_emotion&quot;: &quot;excited&quot;,&#10;                  &quot;emotion_intensity&quot;: 0.8,&#10;                  &quot;previous_emotion&quot;: &quot;happy&quot;,&#10;                  &quot;transition_reason&quot;: &quot;User shared good news&quot;,&#10;                  &quot;suggested_responses&quot;: [&#10;                      &quot;That's fantastic news!&quot;,&#10;                      &quot;I'm so excited for you!&quot;,&#10;                      &quot;Congratulations on your achievement!&quot;&#10;                  ]&#10;              }&#10;&#10;              # 执行情绪设置&#10;              response = test_client.post(&#10;                  f&quot;/api/v1/character/{sample_character_config.id}/emotion&quot;,&#10;                  json=emotion_request&#10;              )&#10;&#10;              # 验证情绪转换&#10;              assert response.status_code == 200&#10;              response_data = response.json()&#10;              assert response_data[&quot;success&quot;] is True&#10;              assert response_data[&quot;current_emotion&quot;] == &quot;excited&quot;&#10;              assert response_data[&quot;emotion_intensity&quot;] == 0.8&#10;              assert len(response_data[&quot;suggested_responses&quot;]) &gt; 0&#10;E       fixture 'test_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestEmotionSystem::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:402&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 402
      @pytest.mark.asyncio
      async def test_character_emotion_transition(self, test_client, sample_character_config):
          """测试角色情绪转换"""
          # 设置情绪请求
          emotion_request = {
              "emotion": "excited",
              "intensity": 0.8,
              "duration": 300,
              "reason": "User shared good news",
              "transition_type": "gradual"
          }

          with patch.object(test_client, 'post') as mock_post:
              mock_post.return_value.status_code = 200
              mock_post.return_value.json.return_value = {
                  "success": True,
                  "current_emotion": "excited",
                  "emotion_intensity": 0.8,
                  "previous_emotion": "happy",
                  "transition_reason": "User shared good news",
                  "suggested_responses": [
                      "That's fantastic news!",
                      "I'm so excited for you!",
                      "Congratulations on your achievement!"
                  ]
              }

              # 执行情绪设置
              response = test_client.post(
                  f"/api/v1/character/{sample_character_config.id}/emotion",
                  json=emotion_request
              )

              # 验证情绪转换
              assert response.status_code == 200
              response_data = response.json()
              assert response_data["success"] is True
              assert response_data["current_emotion"] == "excited"
              assert response_data["emotion_intensity"] == 0.8
              assert len(response_data["suggested_responses"]) &gt; 0
E       fixture 'test_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestEmotionSystem::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:402</error></testcase><testcase classname="integration.test_full_system.TestChatAPIIntegration" name="test_chat_completion_with_character" time="0.376"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 257&#10;      @pytest.mark.asyncio&#10;      async def test_chat_completion_with_character(self, test_client, sample_character_config):&#10;          &quot;&quot;&quot;测试带角色的聊天完成&quot;&quot;&quot;&#10;          chat_request = {&#10;              &quot;messages&quot;: [&#10;                  {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Hello, tell me about yourself&quot;}&#10;              ],&#10;              &quot;character_id&quot;: sample_character_config.id,&#10;              &quot;model&quot;: &quot;test-model&quot;,&#10;              &quot;temperature&quot;: 0.7&#10;          }&#10;&#10;          # 模拟API调用&#10;          with patch.object(test_client, 'post') as mock_post:&#10;              mock_post.return_value.status_code = 200&#10;              mock_post.return_value.json.return_value = {&#10;                  &quot;id&quot;: &quot;chatcmpl-test123&quot;,&#10;                  &quot;object&quot;: &quot;chat.completion&quot;,&#10;                  &quot;model&quot;: &quot;test-model&quot;,&#10;                  &quot;choices&quot;: [{&#10;                      &quot;index&quot;: 0,&#10;                      &quot;message&quot;: {&#10;                          &quot;role&quot;: &quot;assistant&quot;,&#10;                          &quot;content&quot;: &quot;Hello! I'm 测试紫舒, a cheerful AI assistant here to help you!&quot;,&#10;                          &quot;emotion&quot;: &quot;happy&quot;&#10;                      },&#10;                      &quot;finish_reason&quot;: &quot;stop&quot;&#10;                  }],&#10;                  &quot;usage&quot;: {&#10;                      &quot;prompt_tokens&quot;: 20,&#10;                      &quot;completion_tokens&quot;: 15,&#10;                      &quot;total_tokens&quot;: 35&#10;                  }&#10;              }&#10;&#10;              # 执行聊天请求&#10;              response = test_client.post(&#10;                  &quot;/api/v1/chat/completions&quot;,&#10;                  json=chat_request&#10;              )&#10;&#10;              # 验证响应&#10;              assert response.status_code == 200&#10;              response_data = response.json()&#10;              assert response_data[&quot;object&quot;] == &quot;chat.completion&quot;&#10;              assert len(response_data[&quot;choices&quot;]) == 1&#10;&#10;              message = response_data[&quot;choices&quot;][0][&quot;message&quot;]&#10;              assert message[&quot;role&quot;] == &quot;assistant&quot;&#10;              assert &quot;测试紫舒&quot; in message[&quot;content&quot;]&#10;              assert message[&quot;emotion&quot;] == &quot;happy&quot;&#10;E       fixture 'test_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestChatAPIIntegration::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:257&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 257
      @pytest.mark.asyncio
      async def test_chat_completion_with_character(self, test_client, sample_character_config):
          """测试带角色的聊天完成"""
          chat_request = {
              "messages": [
                  {"role": "user", "content": "Hello, tell me about yourself"}
              ],
              "character_id": sample_character_config.id,
              "model": "test-model",
              "temperature": 0.7
          }

          # 模拟API调用
          with patch.object(test_client, 'post') as mock_post:
              mock_post.return_value.status_code = 200
              mock_post.return_value.json.return_value = {
                  "id": "chatcmpl-test123",
                  "object": "chat.completion",
                  "model": "test-model",
                  "choices": [{
                      "index": 0,
                      "message": {
                          "role": "assistant",
                          "content": "Hello! I'm 测试紫舒, a cheerful AI assistant here to help you!",
                          "emotion": "happy"
                      },
                      "finish_reason": "stop"
                  }],
                  "usage": {
                      "prompt_tokens": 20,
                      "completion_tokens": 15,
                      "total_tokens": 35
                  }
              }

              # 执行聊天请求
              response = test_client.post(
                  "/api/v1/chat/completions",
                  json=chat_request
              )

              # 验证响应
              assert response.status_code == 200
              response_data = response.json()
              assert response_data["object"] == "chat.completion"
              assert len(response_data["choices"]) == 1

              message = response_data["choices"][0]["message"]
              assert message["role"] == "assistant"
              assert "测试紫舒" in message["content"]
              assert message["emotion"] == "happy"
E       fixture 'test_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestChatAPIIntegration::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:257</error></testcase><testcase classname="integration.test_full_system.TestChatAPIIntegration" name="test_stream_chat_with_emotion" time="0.376"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 309&#10;      @pytest.mark.asyncio&#10;      async def test_stream_chat_with_emotion(self, test_client, sample_character_config):&#10;          &quot;&quot;&quot;测试带情绪的流式聊天&quot;&quot;&quot;&#10;          stream_request = {&#10;              &quot;messages&quot;: &quot;I'm feeling a bit sad today&quot;,&#10;              &quot;character_id&quot;: sample_character_config.id,&#10;              &quot;current_emotion&quot;: &quot;sad&quot;,&#10;              &quot;analyze_emotion&quot;: True&#10;          }&#10;&#10;          # 模拟流式响应&#10;          mock_chunks = [&#10;              {&quot;id&quot;: &quot;chunk-1&quot;, &quot;choices&quot;: [{&quot;delta&quot;: {&quot;content&quot;: &quot;I'm&quot;}}]},&#10;              {&quot;id&quot;: &quot;chunk-2&quot;, &quot;choices&quot;: [{&quot;delta&quot;: {&quot;content&quot;: &quot; sorry&quot;}}]},&#10;              {&quot;id&quot;: &quot;chunk-3&quot;, &quot;choices&quot;: [{&quot;delta&quot;: {&quot;content&quot;: &quot; to hear&quot;}}]},&#10;              {&quot;id&quot;: &quot;chunk-4&quot;, &quot;choices&quot;: [{&quot;delta&quot;: {&quot;content&quot;: &quot; that.&quot;}}]},&#10;              {&quot;id&quot;: &quot;chunk-5&quot;, &quot;choices&quot;: [{&quot;delta&quot;: {}, &quot;finish_reason&quot;: &quot;stop&quot;}]}&#10;          ]&#10;&#10;          with patch.object(test_client, 'post') as mock_post:&#10;              # 模拟流式响应&#10;              mock_response = Mock()&#10;              mock_response.status_code = 200&#10;              mock_response.iter_lines.return_value = [&#10;                  f&quot;data: {json.dumps(chunk)}&quot; for chunk in mock_chunks&#10;              ] + [&quot;data: [DONE]&quot;]&#10;              mock_post.return_value = mock_response&#10;&#10;              # 执行流式请求&#10;              response = test_client.post(&#10;                  &quot;/api/v1/chat/stream&quot;,&#10;                  json=stream_request&#10;              )&#10;&#10;              # 验证响应&#10;              assert response.status_code == 200&#10;&#10;              # 处理流式数据&#10;              full_response = &quot;&quot;&#10;              for line in response.iter_lines():&#10;                  if line.startswith(&quot;data: &quot;) and not line.endswith(&quot;[DONE]&quot;):&#10;                      chunk_data = json.loads(line[6:])&#10;                      if &quot;choices&quot; in chunk_data and chunk_data[&quot;choices&quot;]:&#10;                          delta = chunk_data[&quot;choices&quot;][0].get(&quot;delta&quot;, {})&#10;                          if &quot;content&quot; in delta:&#10;                              full_response += delta[&quot;content&quot;]&#10;&#10;              assert &quot;sorry to hear that&quot; in full_response&#10;E       fixture 'test_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestChatAPIIntegration::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:309&quot;">file /root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py, line 309
      @pytest.mark.asyncio
      async def test_stream_chat_with_emotion(self, test_client, sample_character_config):
          """测试带情绪的流式聊天"""
          stream_request = {
              "messages": "I'm feeling a bit sad today",
              "character_id": sample_character_config.id,
              "current_emotion": "sad",
              "analyze_emotion": True
          }

          # 模拟流式响应
          mock_chunks = [
              {"id": "chunk-1", "choices": [{"delta": {"content": "I'm"}}]},
              {"id": "chunk-2", "choices": [{"delta": {"content": " sorry"}}]},
              {"id": "chunk-3", "choices": [{"delta": {"content": " to hear"}}]},
              {"id": "chunk-4", "choices": [{"delta": {"content": " that."}}]},
              {"id": "chunk-5", "choices": [{"delta": {}, "finish_reason": "stop"}]}
          ]

          with patch.object(test_client, 'post') as mock_post:
              # 模拟流式响应
              mock_response = Mock()
              mock_response.status_code = 200
              mock_response.iter_lines.return_value = [
                  f"data: {json.dumps(chunk)}" for chunk in mock_chunks
              ] + ["data: [DONE]"]
              mock_post.return_value = mock_response

              # 执行流式请求
              response = test_client.post(
                  "/api/v1/chat/stream",
                  json=stream_request
              )

              # 验证响应
              assert response.status_code == 200

              # 处理流式数据
              full_response = ""
              for line in response.iter_lines():
                  if line.startswith("data: ") and not line.endswith("[DONE]"):
                      chunk_data = json.loads(line[6:])
                      if "choices" in chunk_data and chunk_data["choices"]:
                          delta = chunk_data["choices"][0].get("delta", {})
                          if "content" in delta:
                              full_response += delta["content"]

              assert "sorry to hear that" in full_response
E       fixture 'test_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, integration/test_full_system.py::&lt;event_loop&gt;, integration/test_full_system.py::TestChatAPIIntegration::&lt;event_loop&gt;, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/integration/test_full_system.py:309</error></testcase><testcase classname="unit.api.test_dependencies.TestDependencyIntegration" name="test_full_dependency_setup" time="0.405"><failure message="AttributeError: 'DependencyContainer' object has no attribute 'has_service'">self = &lt;test_dependencies.TestDependencyIntegration object at 0x7fa35e262a30&gt;
temp_config_dir = PosixPath('/tmp/tmp9ta9pmr1')

    def test_full_dependency_setup(self, temp_config_dir):
        """测试完整的依赖设置"""
        container = DependencyContainer()
    
        # 注册基础服务
        logger = setup_logger("test_logger")
        container.register_singleton("logger", logger)
    
        config_manager = Mock(spec=ConfigManager)
        container.register_singleton("config_manager", config_manager)
    
        model_registry = Mock(spec=ModelRegistry)
        container.register_singleton("model_registry", model_registry)
    
        performance_monitor = Mock(spec=PerformanceMonitor)
        container.register_singleton("performance_monitor", performance_monitor)
    
        thread_factory = Mock(spec=ThreadFactory)
        container.register_singleton("thread_factory", thread_factory)
    
        # 验证所有服务都已注册
&gt;       assert container.has_service("logger")
E       AttributeError: 'DependencyContainer' object has no attribute 'has_service'

tests/unit/api/test_dependencies.py:324: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyIntegration" name="test_async_dependency_usage" time="0.394"><failure message="RuntimeError: There is no current event loop in thread 'MainThread'.">self = &lt;Coroutine test_async_dependency_usage&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:926: in inner
    _loop = _get_event_loop_no_warn()
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:882: in _get_event_loop_no_warn
    return asyncio.get_event_loop()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa365ca6640&gt;

    def get_event_loop(self):
        """Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
&gt;           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'MainThread'.

/root/miniconda3/lib/python3.8/asyncio/events.py:639: RuntimeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyIntegration" name="test_error_handling_in_dependencies" time="0.331"><failure message="AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'">self = &lt;test_dependencies.TestDependencyIntegration object at 0x7fa35e262f10&gt;

    def test_error_handling_in_dependencies(self):
        """测试依赖注入中的错误处理"""
        container = DependencyContainer()
    
        # 测试获取不存在的服务
&gt;       with patch('zishu.api.dependencies.get_container', return_value=container):

tests/unit/api/test_dependencies.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/unittest/mock.py:1393: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7fa35d20c0d0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'

/root/miniconda3/lib/python3.8/unittest/mock.py:1366: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyIntegration" name="test_dependency_injection_with_mock_services" time="0.486"><failure message="AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'">self = &lt;test_dependencies.TestDependencyIntegration object at 0x7fa35e262ca0&gt;

    def test_dependency_injection_with_mock_services(self):
        """测试使用模拟服务的依赖注入"""
        container = DependencyContainer()
    
        # 创建模拟服务
        mock_services = {
            "logger": Mock(),
            "config_manager": Mock(),
            "model_registry": Mock(),
            "performance_monitor": Mock(),
            "thread_factory": Mock()
        }
    
        # 注册所有模拟服务
        for name, service in mock_services.items():
            container.register_singleton(name, service)
    
        # 测试服务间的依赖关系
&gt;       with patch('zishu.api.dependencies.get_container', return_value=container):

tests/unit/api/test_dependencies.py:355: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/unittest/mock.py:1393: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7fa35d47d4c0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'

/root/miniconda3/lib/python3.8/unittest/mock.py:1366: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_register_factory" time="0.503" /><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_get_singleton" time="0.396"><failure message="AttributeError: 'DependencyContainer' object has no attribute 'get_singleton'">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e253610&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d47d4c0&gt;
mock_service = &lt;Mock id='140339621386416'&gt;

    def test_get_singleton(self, container, mock_service):
        """测试获取单例"""
        container.register_singleton("test_singleton", mock_service)
    
        # 第一次获取
&gt;       singleton1 = container.get_singleton("test_singleton")
E       AttributeError: 'DependencyContainer' object has no attribute 'get_singleton'

tests/unit/api/test_dependencies.py:88: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_register_service" time="0.403" /><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_has_service" time="0.395"><failure message="AttributeError: 'DependencyContainer' object has no attribute 'has_service'">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e23ba00&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d47d070&gt;
mock_service = &lt;Mock id='140339621385264'&gt;

    def test_has_service(self, container, mock_service):
        """测试检查服务是否存在"""
&gt;       assert not container.has_service("test_service")
E       AttributeError: 'DependencyContainer' object has no attribute 'has_service'

tests/unit/api/test_dependencies.py:112: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_remove_service" time="0.338"><failure message="AttributeError: 'DependencyContainer' object has no attribute 'has_service'">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e253790&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35dafe2b0&gt;
mock_service = &lt;Mock id='140339628206880'&gt;

    def test_remove_service(self, container, mock_service):
        """测试移除服务"""
        container.register_service("test_service", mock_service)
&gt;       assert container.has_service("test_service")
E       AttributeError: 'DependencyContainer' object has no attribute 'has_service'

tests/unit/api/test_dependencies.py:120: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_register_singleton" time="0.402"><failure message="AssertionError: assert 'test_singleton' in {}&#10; +  where {} = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d47d250&gt;._singletons">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e24ee20&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d47d250&gt;
mock_service = &lt;Mock id='140339621385888'&gt;

    def test_register_singleton(self, container, mock_service):
        """测试单例注册"""
        container.register_singleton("test_singleton", mock_service)
&gt;       assert "test_singleton" in container._singletons
E       AssertionError: assert 'test_singleton' in {}
E        +  where {} = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d47d250&gt;._singletons

tests/unit/api/test_dependencies.py:69: AssertionError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_get_service" time="0.401"><failure message="AttributeError: 'DependencyContainer' object has no attribute 'get_service'">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e253100&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d47d610&gt;
mock_service = &lt;Mock id='140339622364160'&gt;

    def test_get_service(self, container, mock_service):
        """测试获取服务"""
        container.register_service("test_service", mock_service)
&gt;       retrieved_service = container.get_service("test_service")
E       AttributeError: 'DependencyContainer' object has no attribute 'get_service'

tests/unit/api/test_dependencies.py:75: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_factory_creation" time="0.399"><failure message="AttributeError: 'DependencyContainer' object has no attribute 'create_from_factory'">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e24e730&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d47d100&gt;

    def test_factory_creation(self, container):
        """测试工厂函数创建实例"""
        def factory():
            return Mock(name="factory_instance")
    
        container.register_factory("test_factory", factory)
    
        # 每次调用工厂应该创建新实例
&gt;       instance1 = container.create_from_factory("test_factory")
E       AttributeError: 'DependencyContainer' object has no attribute 'create_from_factory'

tests/unit/api/test_dependencies.py:103: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_thread_safety" time="0.458"><failure message="AttributeError: 'DependencyContainer' object has no attribute 'has_service'">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e253ca0&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35dac6670&gt;

    def test_thread_safety(self, container):
        """测试线程安全性"""
        results = []
    
        def register_service(i):
            service = Mock(name=f"service_{i}")
            container.register_service(f"service_{i}", service)
            results.append(f"service_{i}")
    
        # 创建多个线程同时注册服务
        threads = []
        for i in range(10):
            thread = threading.Thread(target=register_service, args=(i,))
            threads.append(thread)
            thread.start()
    
        # 等待所有线程完成
        for thread in threads:
            thread.join()
    
        # 验证所有服务都被正确注册
        assert len(results) == 10
        assert len(container._services) == 10
        for i in range(10):
&gt;           assert container.has_service(f"service_{i}")
E           AttributeError: 'DependencyContainer' object has no attribute 'has_service'

tests/unit/api/test_dependencies.py:164: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_container_initialization" time="0.404"><failure message="TypeError: isinstance() arg 2 must be a type or tuple of types">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e24e670&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d47d700&gt;

    def test_container_initialization(self, container):
        """测试容器初始化"""
        assert not container._initialized
        assert len(container._services) == 0
        assert len(container._factories) == 0
        assert len(container._singletons) == 0
&gt;       assert isinstance(container._lock, threading.RLock)
E       TypeError: isinstance() arg 2 must be a type or tuple of types

tests/unit/api/test_dependencies.py:49: TypeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_clear_services" time="0.474"><failure message="assert 0 == 1&#10; +  where 0 = len({})&#10; +    where {} = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d4e0d90&gt;._singletons">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e253a30&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d4e0d90&gt;
mock_service = &lt;Mock id='140339621793696'&gt;

    def test_clear_services(self, container, mock_service):
        """测试清空所有服务"""
        container.register_service("service1", mock_service)
        container.register_service("service2", Mock())
        container.register_singleton("singleton1", Mock())
    
        assert len(container._services) == 2
&gt;       assert len(container._singletons) == 1
E       assert 0 == 1
E        +  where 0 = len({})
E        +    where {} = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d4e0d90&gt;._singletons

tests/unit/api/test_dependencies.py:132: AssertionError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyContainer" name="test_get_service_not_found" time="0.476"><failure message="AttributeError: 'DependencyContainer' object has no attribute 'get_service'">self = &lt;test_dependencies.TestDependencyContainer object at 0x7fa35e253370&gt;
container = &lt;zishu.api.dependencies.DependencyContainer object at 0x7fa35d47dcd0&gt;

    def test_get_service_not_found(self, container):
        """测试获取不存在的服务"""
        with pytest.raises(KeyError):
&gt;           container.get_service("nonexistent_service")
E           AttributeError: 'DependencyContainer' object has no attribute 'get_service'

tests/unit/api/test_dependencies.py:81: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestServiceLifecycle" name="test_service_lifecycle_interface" time="0.528" /><testcase classname="unit.api.test_dependencies.TestServiceLifecycle" name="test_abstract_methods" time="0.463" /><testcase classname="unit.api.test_dependencies.TestDependencyFunctions" name="test_get_config_manager" time="0.524"><failure message="AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'">args = (&lt;test_dependencies.TestDependencyFunctions object at 0x7fa35e25a430&gt;,)
keywargs = {'mock_container': &lt;Mock id='140339621792352'&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/root/miniconda3/lib/python3.8/unittest/mock.py:1322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/contextlib.py:113: in __enter__
    return next(self.gen)
/root/miniconda3/lib/python3.8/unittest/mock.py:1304: in decoration_helper
    arg = exit_stack.enter_context(patching)
/root/miniconda3/lib/python3.8/contextlib.py:425: in enter_context
    result = _cm_type.__enter__(cm)
/root/miniconda3/lib/python3.8/unittest/mock.py:1393: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7fa35e244850&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'

/root/miniconda3/lib/python3.8/unittest/mock.py:1366: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyFunctions" name="test_get_thread_factory_from_deps" time="0.469"><failure message="AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'">args = (&lt;test_dependencies.TestDependencyFunctions object at 0x7fa35e25ab80&gt;,)
keywargs = {'mock_container': &lt;Mock id='140339621278000'&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/root/miniconda3/lib/python3.8/unittest/mock.py:1322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/contextlib.py:113: in __enter__
    return next(self.gen)
/root/miniconda3/lib/python3.8/unittest/mock.py:1304: in decoration_helper
    arg = exit_stack.enter_context(patching)
/root/miniconda3/lib/python3.8/contextlib.py:425: in enter_context
    result = _cm_type.__enter__(cm)
/root/miniconda3/lib/python3.8/unittest/mock.py:1393: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7fa35e244b20&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'

/root/miniconda3/lib/python3.8/unittest/mock.py:1366: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyFunctions" name="test_get_logger" time="0.483"><failure message="AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'">args = (&lt;test_dependencies.TestDependencyFunctions object at 0x7fa35e25a1c0&gt;,)
keywargs = {'mock_container': &lt;Mock id='140339628229488'&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/root/miniconda3/lib/python3.8/unittest/mock.py:1322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/contextlib.py:113: in __enter__
    return next(self.gen)
/root/miniconda3/lib/python3.8/unittest/mock.py:1304: in decoration_helper
    arg = exit_stack.enter_context(patching)
/root/miniconda3/lib/python3.8/contextlib.py:425: in enter_context
    result = _cm_type.__enter__(cm)
/root/miniconda3/lib/python3.8/unittest/mock.py:1393: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7fa35e244760&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'

/root/miniconda3/lib/python3.8/unittest/mock.py:1366: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyFunctions" name="test_get_model_registry" time="0.493"><failure message="AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'">args = (&lt;test_dependencies.TestDependencyFunctions object at 0x7fa35e25a6a0&gt;,)
keywargs = {'mock_container': &lt;Mock id='140339621278816'&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/root/miniconda3/lib/python3.8/unittest/mock.py:1322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/contextlib.py:113: in __enter__
    return next(self.gen)
/root/miniconda3/lib/python3.8/unittest/mock.py:1304: in decoration_helper
    arg = exit_stack.enter_context(patching)
/root/miniconda3/lib/python3.8/contextlib.py:425: in enter_context
    result = _cm_type.__enter__(cm)
/root/miniconda3/lib/python3.8/unittest/mock.py:1393: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7fa35e244940&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'

/root/miniconda3/lib/python3.8/unittest/mock.py:1366: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyFunctions" name="test_get_character_config" time="0.414"><failure message="AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'">args = (&lt;test_dependencies.TestDependencyFunctions object at 0x7fa35e25adf0&gt;,)
keywargs = {'mock_container': &lt;Mock id='140339620236784'&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/root/miniconda3/lib/python3.8/unittest/mock.py:1322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/contextlib.py:113: in __enter__
    return next(self.gen)
/root/miniconda3/lib/python3.8/unittest/mock.py:1304: in decoration_helper
    arg = exit_stack.enter_context(patching)
/root/miniconda3/lib/python3.8/contextlib.py:425: in enter_context
    result = _cm_type.__enter__(cm)
/root/miniconda3/lib/python3.8/unittest/mock.py:1393: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7fa35e244c10&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'

/root/miniconda3/lib/python3.8/unittest/mock.py:1366: AttributeError</failure></testcase><testcase classname="unit.api.test_dependencies.TestDependencyFunctions" name="test_get_performance_monitor" time="0.401"><failure message="AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'">args = (&lt;test_dependencies.TestDependencyFunctions object at 0x7fa35e25a910&gt;,)
keywargs = {'mock_container': &lt;Mock id='140339621280784'&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/root/miniconda3/lib/python3.8/unittest/mock.py:1322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/contextlib.py:113: in __enter__
    return next(self.gen)
/root/miniconda3/lib/python3.8/unittest/mock.py:1304: in decoration_helper
    arg = exit_stack.enter_context(patching)
/root/miniconda3/lib/python3.8/contextlib.py:425: in enter_context
    result = _cm_type.__enter__(cm)
/root/miniconda3/lib/python3.8/unittest/mock.py:1393: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7fa35e244a30&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'zishu.api.dependencies' from '/root/autodl-tmp/Zishu-sensei/zishu/api/dependencies.py'&gt; does not have the attribute 'get_container'

/root/miniconda3/lib/python3.8/unittest/mock.py:1366: AttributeError</failure></testcase><testcase classname="integration.test_api_integration.TestAPIDataConsistency" name="test_response_format_consistency" time="0.506"><failure message="assert 500 == 200&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestAPIDataConsistency object at 0x7fa365e17e80&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d5d1430&gt;

    def test_response_format_consistency(self, client):
        """测试响应格式一致性"""
        # 发送多个相似请求
        requests = [
            {"messages": [{"role": "user", "content": f"Test {i}"}], "model": "test-model"}
            for i in range(5)
        ]
    
        responses = []
        for request in requests:
            response = client.post("/api/v1/chat/completions", json=request)
&gt;           assert response.status_code == 200
E           assert 500 == 200
E            +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:600: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestAPIDataConsistency" name="test_error_format_consistency" time="0.413"><failure message="assert 500 == 422&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestAPIDataConsistency object at 0x7fa365e1c160&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d463e80&gt;

    def test_error_format_consistency(self, client):
        """测试错误格式一致性"""
        # 发送多个无效请求
        invalid_requests = [
            {},  # 空请求
            {"model": "test"},  # 缺少messages
            {"messages": []},  # 缺少model
            {"messages": "invalid", "model": "test"}  # 错误类型
        ]
    
        error_responses = []
        for request in invalid_requests:
            response = client.post("/api/v1/chat/completions", json=request)
&gt;           assert response.status_code == 422
E           assert 500 == 422
E            +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:632: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestModelManagementIntegration" name="test_list_adapters_endpoint" time="0.419"><skipped type="pytest.skip" message="Models endpoint not implemented">/root/autodl-tmp/Zishu-sensei/tests/integration/test_api_integration.py:306: Models endpoint not implemented</skipped></testcase><testcase classname="integration.test_api_integration.TestModelManagementIntegration" name="test_load_adapter_endpoint" time="0.498"><skipped type="pytest.skip" message="Load adapter endpoint not implemented">/root/autodl-tmp/Zishu-sensei/tests/integration/test_api_integration.py:334: Load adapter endpoint not implemented</skipped></testcase><testcase classname="integration.test_api_integration.TestModelManagementIntegration" name="test_model_status_endpoint" time="0.484"><skipped type="pytest.skip" message="Model status endpoint not implemented">/root/autodl-tmp/Zishu-sensei/tests/integration/test_api_integration.py:317: Model status endpoint not implemented</skipped></testcase><testcase classname="integration.test_api_integration.TestChatIntegration" name="test_chat_completions_concurrent" time="0.989"><failure message="assert 500 == 200&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestChatIntegration object at 0x7fa365e8a730&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d4849a0&gt;

    def test_chat_completions_concurrent(self, client):
        """测试并发聊天请求"""
        import concurrent.futures
        import threading
    
        def make_request(i):
            request_data = {
                "messages": [{"role": "user", "content": f"Request {i}"}],
                "model": "test-model"
            }
            return client.post("/api/v1/chat/completions", json=request_data)
    
        # 并发发送多个请求
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(make_request, i) for i in range(10)]
            responses = [future.result() for future in futures]
    
        # 验证所有请求都成功
        for response in responses:
&gt;           assert response.status_code == 200
E           assert 500 == 200
E            +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:288: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestChatIntegration" name="test_chat_completions_basic" time="0.705"><failure message="assert 500 == 200&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestChatIntegration object at 0x7fa365e83ca0&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35daaf9a0&gt;

    def test_chat_completions_basic(self, client):
        """测试基本聊天完成"""
        request_data = {
            "messages": [{"role": "user", "content": "Hello"}],
            "model": "test-model",
            "temperature": 0.7,
            "max_tokens": 100
        }
    
        response = client.post("/api/v1/chat/completions", json=request_data)
    
&gt;       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:206: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestChatIntegration" name="test_chat_completions_invalid_request" time="0.624"><failure message="assert 500 == 422&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestChatIntegration object at 0x7fa365e83280&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d484670&gt;

    def test_chat_completions_invalid_request(self, client):
        """测试无效的聊天请求"""
        # 缺少必需字段
        request_data = {
            "model": "test-model"
            # 缺少messages字段
        }
    
        response = client.post("/api/v1/chat/completions", json=request_data)
    
&gt;       assert response.status_code == 422  # Validation error
E       assert 500 == 422
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:241: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestChatIntegration" name="test_chat_completions_with_history" time="0.709"><failure message="assert 500 == 200&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestChatIntegration object at 0x7fa365ec7400&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d488c40&gt;

    def test_chat_completions_with_history(self, client):
        """测试带历史记录的聊天"""
        request_data = {
            "messages": [
                {"role": "user", "content": "Hello"},
                {"role": "assistant", "content": "Hi there!"},
                {"role": "user", "content": "How are you?"}
            ],
            "model": "test-model"
        }
    
        response = client.post("/api/v1/chat/completions", json=request_data)
    
&gt;       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:226: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestChatIntegration" name="test_chat_completions_empty_messages" time="0.441"><failure message="assert 500 in [400, 422]&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestChatIntegration object at 0x7fa365e8a160&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d484730&gt;

    def test_chat_completions_empty_messages(self, client):
        """测试空消息列表"""
        request_data = {
            "messages": [],
            "model": "test-model"
        }
    
        response = client.post("/api/v1/chat/completions", json=request_data)
    
        # 可能返回400或422，取决于验证逻辑
&gt;       assert response.status_code in [400, 422]
E       assert 500 in [400, 422]
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:253: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestChatIntegration" name="test_chat_completions_async" time="0.456"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_chat_completions_async&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="integration.test_api_integration.TestAPIWorkflow" name="test_complete_chat_workflow" time="0.591"><failure message="assert 500 == 200&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestAPIWorkflow object at 0x7fa365e13640&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d36e280&gt;

    def test_complete_chat_workflow(self, client):
        """测试完整的聊天工作流"""
        # 1. 检查健康状态
        health_response = client.get("/health")
        assert health_response.status_code == 200
    
        # 2. 检查模型状态（如果端点存在）
        model_status_response = client.get("/models/status")
        if model_status_response.status_code != 404:
            assert model_status_response.status_code == 200
    
        # 3. 发送聊天请求
        chat_request = {
            "messages": [{"role": "user", "content": "Hello, how are you?"}],
            "model": "test-model",
            "temperature": 0.7
        }
    
        chat_response = client.post("/api/v1/chat/completions", json=chat_request)
&gt;       assert chat_response.status_code == 200
E       assert 500 == 200
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:364: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestAPIWorkflow" name="test_error_handling_workflow" time="0.411"><failure message="assert 500 == 422&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestAPIWorkflow object at 0x7fa365e138e0&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d182310&gt;

    def test_error_handling_workflow(self, client):
        """测试错误处理工作流"""
        # 1. 发送无效请求
        invalid_request = {
            "messages": "invalid_format",  # 应该是列表
            "model": "test-model"
        }
    
        response = client.post("/api/v1/chat/completions", json=invalid_request)
&gt;       assert response.status_code == 422
E       assert 500 == 422
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:385: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestAPIWorkflow" name="test_async_workflow" time="0.480"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_async_workflow&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="integration.test_api_integration.TestHealthIntegration" name="test_health_endpoint_async" time="0.403"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_health_endpoint_async&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="integration.test_api_integration.TestHealthIntegration" name="test_health_endpoint_with_cors" time="0.624" /><testcase classname="integration.test_api_integration.TestHealthIntegration" name="test_health_endpoint_performance" time="0.772" /><testcase classname="integration.test_api_integration.TestHealthIntegration" name="test_health_endpoint_basic" time="0.405" /><testcase classname="integration.test_api_integration.TestAPISecurityIntegration" name="test_security_headers" time="0.416" /><testcase classname="integration.test_api_integration.TestAPISecurityIntegration" name="test_cors_headers" time="0.399"><failure message="AttributeError: 'SyncASGIClient' object has no attribute 'options'">self = &lt;test_api_integration.TestAPISecurityIntegration object at 0x7fa365e17100&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d4c4e50&gt;

    def test_cors_headers(self, client):
        """测试CORS头设置"""
        # 预检请求
&gt;       response = client.options(
            "/api/v1/chat/completions",
            headers={
                "Origin": "http://localhost:3000",
                "Access-Control-Request-Method": "POST",
                "Access-Control-Request-Headers": "Content-Type"
            }
        )
E       AttributeError: 'SyncASGIClient' object has no attribute 'options'

tests/integration/test_api_integration.py:443: AttributeError</failure></testcase><testcase classname="integration.test_api_integration.TestAPISecurityIntegration" name="test_rate_limiting" time="0.697" /><testcase classname="integration.test_api_integration.TestAPISecurityIntegration" name="test_request_size_limits" time="1.819"><failure message="assert 500 in [413, 422, 400]&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestAPISecurityIntegration object at 0x7fa365e17640&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35cfd8910&gt;

    def test_request_size_limits(self, client):
        """测试请求大小限制"""
        # 创建一个非常大的请求
        huge_content = "x" * (50 * 1024 * 1024)  # 50MB
        large_request = {
            "messages": [{"role": "user", "content": huge_content}],
            "model": "test-model"
        }
    
        response = client.post("/api/v1/chat/completions", json=large_request)
    
        # 应该被拒绝（413 Request Entity Too Large 或其他错误）
&gt;       assert response.status_code in [413, 422, 400]
E       assert 500 in [413, 422, 400]
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:485: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestAPIPerformanceIntegration" name="test_memory_usage_stability" time="1.805" /><testcase classname="integration.test_api_integration.TestAPIPerformanceIntegration" name="test_response_time_performance" time="0.420"><failure message="assert 500 == 200&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;test_api_integration.TestAPIPerformanceIntegration object at 0x7fa365e13f10&gt;
client = &lt;test_api_integration.SyncASGIClient object at 0x7fa35d2dcd00&gt;

    def test_response_time_performance(self, client):
        """测试响应时间性能"""
        # 测试健康检查响应时间
        start_time = time.time()
        response = client.get("/health")
        health_time = time.time() - start_time
    
        assert response.status_code == 200
        assert health_time &lt; 1.0  # 健康检查应该很快
    
        # 测试聊天请求响应时间
        chat_request = {
            "messages": [{"role": "user", "content": "Quick test"}],
            "model": "test-model"
        }
    
        start_time = time.time()
        response = client.post("/api/v1/chat/completions", json=chat_request)
        chat_time = time.time() - start_time
    
&gt;       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/integration/test_api_integration.py:528: AssertionError</failure></testcase><testcase classname="integration.test_api_integration.TestAPIPerformanceIntegration" name="test_concurrent_performance" time="1.980" /><testcase classname="unit.api.test_model_routes.TestAdapterStatus" name="test_adapter_status_values" time="0.410" /><testcase classname="unit.api.test_model_routes.TestAdapterStatus" name="test_adapter_status_comparison" time="0.420" /><testcase classname="unit.api.test_model_routes.TestModelOperationType" name="test_operation_type_values" time="0.666" /><testcase classname="unit.api.test_model_routes.TestModelPerformance" name="test_file_info_performance" time="0.496"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_file_info_performance&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelPerformance" name="test_system_info_performance" time="0.398"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_system_info_performance&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelPerformance" name="test_adapter_validation_performance" time="0.414"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_adapter_validation_performance&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelErrorHandling" name="test_switch_adapter_failure" time="0.411"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_switch_adapter_failure&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelErrorHandling" name="test_get_status_failure" time="0.407" /><testcase classname="unit.api.test_model_routes.TestModelErrorHandling" name="test_load_adapter_failure" time="0.418"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_load_adapter_failure&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelErrorHandling" name="test_unload_adapter_failure" time="0.455"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_unload_adapter_failure&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelRoutesIntegration" name="test_get_model_status_endpoint" time="0.401"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_model_routes.py:487: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_model_routes.TestModelRoutesIntegration" name="test_list_adapters_endpoint" time="0.484"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_model_routes.py:471: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_model_routes.TestModelRoutesIntegration" name="test_switch_adapter_endpoint" time="0.685"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_model_routes.py:483: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_model_routes.TestModelRoutesIntegration" name="test_get_adapter_info_endpoint" time="0.422"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_model_routes.py:491: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_model_routes.TestModelRoutesIntegration" name="test_unload_adapter_endpoint" time="0.478"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_model_routes.py:479: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_model_routes.TestModelRoutesIntegration" name="test_load_adapter_endpoint" time="0.504"><skipped type="pytest.skip" message="需要完整的应用设置">/root/autodl-tmp/Zishu-sensei/tests/unit/api/test_model_routes.py:475: 需要完整的应用设置</skipped></testcase><testcase classname="unit.api.test_model_routes.TestModelStress" name="test_memory_cleanup_stress" time="0.410"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_memory_cleanup_stress&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelStress" name="test_concurrent_validation" time="0.396"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_concurrent_validation&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelRouteLogic" name="test_unload_adapter_logic" time="0.349"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_unload_adapter_logic&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelRouteLogic" name="test_switch_adapter_logic" time="0.463"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_switch_adapter_logic&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelRouteLogic" name="test_load_adapter_logic" time="0.509"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_load_adapter_logic&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestModelRouteLogic" name="test_list_adapters_logic" time="0.500"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_list_adapters_logic&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestValidationFunctions" name="test_validate_adapter_name_valid" time="0.406"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_validate_adapter_name_valid&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestValidationFunctions" name="test_validate_adapter_path_safe" time="0.396"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_validate_adapter_path_safe&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestValidationFunctions" name="test_get_adapter_file_info_nonexistent_file" time="0.395"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_get_adapter_file_info_nonexistent_file&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestValidationFunctions" name="test_get_adapter_file_info_directory" time="0.393"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_get_adapter_file_info_directory&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestValidationFunctions" name="test_get_adapter_file_info_existing_file" time="0.393"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_get_adapter_file_info_existing_file&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestValidationFunctions" name="test_validate_adapter_name_invalid" time="0.336"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_validate_adapter_name_invalid&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestValidationFunctions" name="test_validate_adapter_path_unsafe" time="0.575"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_validate_adapter_path_unsafe&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestValidationFunctions" name="test_validate_adapter_name_edge_cases" time="0.396"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_validate_adapter_name_edge_cases&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestUtilityFunctions" name="test_get_system_info_exception" time="0.404"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_get_system_info_exception&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestUtilityFunctions" name="test_cleanup_memory_task_with_torch" time="0.398"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_cleanup_memory_task_with_torch&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestUtilityFunctions" name="test_get_system_info_success" time="0.397"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_get_system_info_success&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestUtilityFunctions" name="test_cleanup_memory_task_exception" time="0.400"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_cleanup_memory_task_exception&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestUtilityFunctions" name="test_cleanup_memory_task" time="0.397"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_cleanup_memory_task&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="unit.api.test_model_routes.TestUtilityFunctions" name="test_get_system_info_with_gpu" time="0.388"><failure message="RuntimeError: Event loop is closed">self = &lt;Coroutine test_get_system_info_with_gpu&gt;

    def runtest(self) -&gt; None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
&gt;       super().runtest()

/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/miniconda3/lib/python3.8/site-packages/pytest_asyncio/plugin.py:927: in inner
    task = asyncio.ensure_future(coro, loop=_loop)
/root/miniconda3/lib/python3.8/asyncio/tasks.py:672: in ensure_future
    task = loop.create_task(coro_or_future)
/root/miniconda3/lib/python3.8/asyncio/base_events.py:429: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;

    def _check_closed(self):
        if self._closed:
&gt;           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/root/miniconda3/lib/python3.8/asyncio/base_events.py:508: RuntimeError</failure></testcase><testcase classname="performance.test_api_performance.TestLoadTesting" name="test_spike_load" time="0.579"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 469&#10;      def test_spike_load(self, perf_client, system_monitor):&#10;E       fixture 'perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestLoadTesting::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:469&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 469
      def test_spike_load(self, perf_client, system_monitor):
E       fixture 'perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestLoadTesting::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:469</error></testcase><testcase classname="performance.test_api_performance.TestLoadTesting" name="test_sustained_load" time="0.405"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 397&#10;      def test_sustained_load(self, perf_client, system_monitor):&#10;E       fixture 'perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestLoadTesting::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:397&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 397
      def test_sustained_load(self, perf_client, system_monitor):
E       fixture 'perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestLoadTesting::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:397</error></testcase><testcase classname="performance.test_api_performance.TestStreamingPerformance" name="test_streaming_response_performance" time="0.402"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 680&#10;      def test_streaming_response_performance(self, perf_client, system_monitor):&#10;E       fixture 'perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestStreamingPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:680&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 680
      def test_streaming_response_performance(self, perf_client, system_monitor):
E       fixture 'perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestStreamingPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:680</error></testcase><testcase classname="performance.test_api_performance.TestBasicPerformance" name="test_health_check_performance" time="0.416"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 134&#10;      def test_health_check_performance(self, perf_client, system_monitor):&#10;E       fixture 'perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestBasicPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:134&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 134
      def test_health_check_performance(self, perf_client, system_monitor):
E       fixture 'perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestBasicPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:134</error></testcase><testcase classname="performance.test_api_performance.TestBasicPerformance" name="test_chat_completion_performance" time="0.402"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 179&#10;      def test_chat_completion_performance(self, perf_client, system_monitor):&#10;E       fixture 'perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestBasicPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:179&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 179
      def test_chat_completion_performance(self, perf_client, system_monitor):
E       fixture 'perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestBasicPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:179</error></testcase><testcase classname="performance.test_api_performance.TestConcurrencyPerformance" name="test_concurrent_chat_completions" time="0.398"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 289&#10;      def test_concurrent_chat_completions(self, perf_client, system_monitor):&#10;E       fixture 'perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestConcurrencyPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:289&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 289
      def test_concurrent_chat_completions(self, perf_client, system_monitor):
E       fixture 'perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestConcurrencyPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:289</error></testcase><testcase classname="performance.test_api_performance.TestConcurrencyPerformance" name="test_concurrent_health_checks" time="0.395"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 238&#10;      def test_concurrent_health_checks(self, perf_client, system_monitor):&#10;E       fixture 'perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestConcurrencyPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:238&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 238
      def test_concurrent_health_checks(self, perf_client, system_monitor):
E       fixture 'perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestConcurrencyPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:238</error></testcase><testcase classname="performance.test_api_performance.TestConcurrencyPerformance" name="test_async_concurrent_performance" time="0.347"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 344&#10;      @pytest.mark.asyncio&#10;      async def test_async_concurrent_performance(self, async_perf_client, system_monitor):&#10;          &quot;&quot;&quot;测试异步并发性能&quot;&quot;&quot;&#10;          num_concurrent = 20&#10;          requests_per_task = 25&#10;          total_requests = num_concurrent * requests_per_task&#10;&#10;          async def make_async_requests(task_id):&#10;              &quot;&quot;&quot;异步请求任务&quot;&quot;&quot;&#10;              task_times = []&#10;              for i in range(requests_per_task):&#10;                  start_time = time.time()&#10;                  response = await async_perf_client.get(&quot;/health&quot;)&#10;                  end_time = time.time()&#10;&#10;                  assert response.status_code == 200&#10;                  task_times.append(end_time - start_time)&#10;&#10;              return task_times&#10;&#10;          # 异步并发测试&#10;          start_time = time.time()&#10;&#10;          tasks = [make_async_requests(i) for i in range(num_concurrent)]&#10;          results = await asyncio.gather(*tasks)&#10;&#10;          total_time = time.time() - start_time&#10;&#10;          # 收集所有响应时间&#10;          all_times = []&#10;          for task_times in results:&#10;              all_times.extend(task_times)&#10;&#10;          # 性能指标&#10;          avg_response_time = statistics.mean(all_times)&#10;          throughput = total_requests / total_time&#10;&#10;          # 异步并发性能断言&#10;          assert avg_response_time &lt; 0.02  # 异步平均响应时间 &lt; 20ms&#10;          assert throughput &gt; 500  # 异步吞吐量 &gt; 500 req/s&#10;&#10;          print(f&quot;\n异步并发性能指标:&quot;)&#10;          print(f&quot;  并发任务数: {num_concurrent}&quot;)&#10;          print(f&quot;  总请求数: {total_requests}&quot;)&#10;          print(f&quot;  平均响应时间: {avg_response_time*1000:.2f}ms&quot;)&#10;          print(f&quot;  吞吐量: {throughput:.2f} req/s&quot;)&#10;E       fixture 'async_perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestConcurrencyPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:344&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 344
      @pytest.mark.asyncio
      async def test_async_concurrent_performance(self, async_perf_client, system_monitor):
          """测试异步并发性能"""
          num_concurrent = 20
          requests_per_task = 25
          total_requests = num_concurrent * requests_per_task

          async def make_async_requests(task_id):
              """异步请求任务"""
              task_times = []
              for i in range(requests_per_task):
                  start_time = time.time()
                  response = await async_perf_client.get("/health")
                  end_time = time.time()

                  assert response.status_code == 200
                  task_times.append(end_time - start_time)

              return task_times

          # 异步并发测试
          start_time = time.time()

          tasks = [make_async_requests(i) for i in range(num_concurrent)]
          results = await asyncio.gather(*tasks)

          total_time = time.time() - start_time

          # 收集所有响应时间
          all_times = []
          for task_times in results:
              all_times.extend(task_times)

          # 性能指标
          avg_response_time = statistics.mean(all_times)
          throughput = total_requests / total_time

          # 异步并发性能断言
          assert avg_response_time &lt; 0.02  # 异步平均响应时间 &lt; 20ms
          assert throughput &gt; 500  # 异步吞吐量 &gt; 500 req/s

          print(f"\n异步并发性能指标:")
          print(f"  并发任务数: {num_concurrent}")
          print(f"  总请求数: {total_requests}")
          print(f"  平均响应时间: {avg_response_time*1000:.2f}ms")
          print(f"  吞吐量: {throughput:.2f} req/s")
E       fixture 'async_perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestConcurrencyPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:344</error></testcase><testcase classname="performance.test_api_performance.TestMemoryPerformance" name="test_large_request_memory_handling" time="0.335"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 624&#10;      def test_large_request_memory_handling(self, perf_client, system_monitor):&#10;E       fixture 'perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestMemoryPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:624&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 624
      def test_large_request_memory_handling(self, perf_client, system_monitor):
E       fixture 'perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestMemoryPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:624</error></testcase><testcase classname="performance.test_api_performance.TestMemoryPerformance" name="test_memory_leak_detection" time="0.404"><error message="failed on setup with &quot;file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 579&#10;      def test_memory_leak_detection(self, perf_client, system_monitor):&#10;E       fixture 'perf_client' not found&#10;&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestMemoryPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:579&quot;">file /root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py, line 579
      def test_memory_leak_detection(self, perf_client, system_monitor):
E       fixture 'perf_client' not found
&gt;       available fixtures: _session_event_loop, _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cleanup_after_test, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, faker_seed, include_metadata_in_junit_xml, json_metadata, metadata, mock_adapter, mock_database, mock_health_checker, mock_logger, mock_model_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance/test_api_performance.py::&lt;event_loop&gt;, performance/test_api_performance.py::TestMemoryPerformance::&lt;event_loop&gt;, performance_config, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, sample_chat_request, sample_chat_response, session_mocker, system_monitor, temp_dir, test_config, test_utils, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/root/autodl-tmp/Zishu-sensei/tests/performance/test_api_performance.py:579</error></testcase></testsuite></testsuites>